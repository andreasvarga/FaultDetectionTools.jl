var documenterSearchIndex = {"docs":
[{"location":"FDIObjects.html#Building-fault-detection-and-isolation-related-objects","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"","category":"section"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"FDIObjects.html","page":"Building fault detection and isolation related objects","title":"Building fault detection and isolation related objects","text":"FDIModel\nfdimodset\nFDFilter\nFDFilter(::DescriptorSystems.DescriptorStateSpace, ::Int, ::Int)\nFDFilterIF\nFDFilterIF(::DescriptorSystems.DescriptorStateSpace; mu, md, mf, mw, ma, moff)\nFDIFilter\nFDIFilter(::Array{DescriptorSystems.DescriptorStateSpace{T},1}, ::Int, ::Int) where T\nFDIFilterIF\nFDIFilterIF(::Array{DescriptorSystems.DescriptorStateSpace{T},1}; mu, md, mf, mw, ma, moff) where T\nfdIFeval","category":"page"},{"location":"FDIObjects.html#FaultDetectionTools.FDIModel","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIModel","text":"FDIModel <: AbstractFDDObject\n\nType for synthesis models employed to solve fault detection and isolation problems.\n\nIf sysf::FDIModel is the synthesis model object, the underlying descriptor system model can be obtained via sysf.sys and the dimensions of the control, disturbance, fault, noise and auxiliary vectors are contained in the integers sysf.mu, sysf.md, sysf.mf, sysf.mw and sysf.ma, respectively. The ranges of indices of control, disturbance, fault, noise and auxiliary inputs can be accessed as sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.fdimodset","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdimodset","text":"fdimodset(sys; controls, c, disturbances, d, faults, f, fa, faults_sen, fs, noise, n, aux) -> sysf::FDIModel\n\nBuild for a given linear time-invariant system model sys = (A-λE,B,C,D), a synthesis model object sysf::FDIModel  to be used in conjunction with the analysis and synthesis functions of FDI filters.  If sys is a vector of system models, then sysf results as a vector of synthesis model objects.\n\nThe information on the partition of the input components in control, disturbance, fault, noise and auxiliary inputs can be specified using the following keyword arguments:\n\ncontrols = inpu or c = inpu specifies the indices inpu of the control inputs (default: void)\n\ndisturbances = inpd or d = inpd specifies the indices inpd of the disturbance inputs (default: void)\n\nfaults = inpf or f  = inpf specifies the indices inpf of the fault inputs (default: void)\n\nfa = inpfa specifies the indices inpfa of control inputs subject to actuator fault (default: void)\n\nfaults_sen = inpfs or fs = inpfs specifies the indices inpfs of the system outputs subject to sensor fault inputs (default: void)\n\nnoise = inpn or  noise = inpn specifies the indices inpn of the noise inputs (default: void)\n\naux = inpa specifies the indices inpa of the auxiliary inputs (default: void)\n\nThe indices of inputs or outputs can be specified as integer vectors, integer scalars or integer UnitRanges.\n\nThe resulting sysf contains the partitioned system  sysf.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]), where  Bu, Bd, Bf, Bw and Bv are the input matrices from the control inputs u, disturbance inputs d, fault inputs f,  noise inputs w and auxiliary inputs v, respectively, and Du, Dd, Df, Dw and Dv are the feedthrough matrices from those inputs. The dimensions of control, disturbance, fault, noise and auxiliary input vectors are contained in  sysm.mu, sysm.md, sysm.mf, sysm.mw and sysm.ma, respectively.  \n\nMethod: If G(λ) is the p x m transfer function matrix of sys, then the resulting system sysf has an  equivalent input output form [Gu(λ) Gd(λ) Gf(λ) Gw(λ) Gv(λ)], where the following relations define the component matrices: Gu(λ) = G(λ)*Su, Gd(λ) = G(λ)*Sd,  Gf(λ) = [G(λ)*Sf Ss], Gw(λ) = G(λ)*Sw,  Gv(λ) = G(λ)*Sv, with the selection matrices Su, Sd, Sf, Sw and Sv formed from the columns of the m-th order identity matrix and  Ss is formed  from the columns of the p-th order identity matrix. \n\n\n\n\n\n","category":"function"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter <: AbstractFDDObject\n\nType for fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilter is the fault detection filter object, the underlying descriptor system model can be obtained via filter.sys and the dimensions of the partitioned filter input vectors as  measured outputs and control inputs,   can be accessed as the integers contained in filter.ny and filter.mu, respectively. The ranges of the indices of output and control inputs  can be accessed as filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilter-Tuple{DescriptorStateSpace, Int64, Int64}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilter","text":"FDFilter(sys, ny, mu) -> Q::FDFilter\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter object Q, as determined with the synthesis functions of FDI filters.  ny and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that B = [By Bu Bv] and D = [Dy Du Dv] are partitioned matrices such that By and Dy have ny columns, and Bu and Du have mu columns,  where By and Bu are the input matrices from the measured outputs y and  control inputs u, Dy and Du are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the partitioned system  Q.sys = (A-λE,[By Bd],C,[Dy Du]) and the dimensions of the  partitioned filter input vectors as  measured outputs and control inputs,   can be accessed as the integers contained in Q.ny and Q.mu, respectively. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection filters resulted as solutions of fault detection problems.\n\nIf filter::FDFilterIF is the fault detection filter internal form object,  the underlying descriptor system model can be obtained via filter.sys and the dimensions of the control, disturbance, fault, noise and auxiliary vectors are contained in the integers filter.mu, filter.md, filter.mf, filter.mw and filter.ma, respectively.  The ranges of indices of control, disturbance, fault, noise and auxiliary inputs can be accessed as filter.controls, filter.disturbances, filter.faults, filter.noise and filter.aux, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDFilterIF-Tuple{DescriptorStateSpace}","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDFilterIF","text":"FDFilterIF(sys; mu = 0, md = 0, mf = 0, mw = 0, ma = 0, moff = 0) -> R::FDFilterIF\n\nBuild for a given linear time-invariant descriptor system model sys = (A-λE,B,C,D),  a fault detection filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and maux are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that B = [Boff Bu Bd Bf Bw Bv] and D = [Doff Du Dd Df Dw Dv] are partitioned matrices such that Boff and Doff have moff columns, Bu and Du have mu columns, Bd and Dd have md columns,  Bf and Df have mf columns,  Bw and Dw have mw columns, and Bv and Dv have maux columns.   \n\nThe resulting R contains the partitioned system  R.sys = (A-λE,[Bu Bd Bf Bw Bv],C,[Du Dd Df Dw Dv]) and  the dimensions of control, disturbance, fault, noise and  auxiliary input vectors are contained in  R.mu, R.md, R.mf, R.mw and R.ma, respectively.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter <: AbstractFDDObject\n\nType for fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilter is the fault detection and isolation filter object,  the underlying i-th descriptor system model can be obtained via filter.sys[i] and the dimensions of the partitioned filter input vectors as  measured outputs and control inputs,   can be accessed as the integers contained in filter.ny and filter.mu, respectively. The ranges of the indices of output and control inputs  can be accessed as filter.outputs and filter.controls, respectively.\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilter-Union{Tuple{T}, Tuple{Array{DescriptorStateSpace{T, ET} where ET<:Union{LinearAlgebra.UniformScaling{Bool}, Matrix{T}}, 1}, Int64, Int64}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilter","text":"FDIFilter(sys, ny, mu) -> Q::FDIFilter\n\nBuild for a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di) with the same number of inputs, a fault detection and isolation filter object Q,  as determined with the synthesis functions of FDI filters.  ny and mu are the number of measured outputs and the number of control inputs, respectively.  It is assumed that each Bi = [Byi Bui Bvi] and Di = [Dyi Dui Dvi] are partitioned matrices such that Byi and Dyi have ny columns, and Bui and Dui have mu columns,  where Byi and Bui are the input matrices from the measured outputs y and  control inputs u, Dyi and Dui are the feedthrough matrices from the measured outputs y and  control inputs u. \n\nThe resulting Q contains the vector of partitioned systems Q.sys[i] = (Ai-λEi,[Byi Bdi],Ci,[Dyi Dui]) and the dimensions of the  partitioned filter input vectors as  measured outputs and control inputs,   can be accessed as the integers contained in Q.ny and Q.mu, respectively. \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF <: AbstractFDDObject\n\nType for the internal form of fault detection and isolation filters resulted as solutions of fault detection and isolation problems.\n\nIf filter::FDIFilterIF is the fault detection and isolation filter internal form object,  the underlying i-th descriptor system model can be obtained via filter.sys[i] and the dimensions of the control, disturbance, fault, noise and auxiliary vectors are contained in the integers filter.mu, filter.md, filter.mf, filter.mw and filter.ma, respectively.  The ranges of indices of control, disturbance, fault, noise and auxiliary inputs can be accessed as filter.controls, filter.disturbances, filter.faults, filter.noise and filter.aux, respectively. .\n\n\n\n\n\n","category":"type"},{"location":"FDIObjects.html#FaultDetectionTools.FDIFilterIF-Union{Tuple{Array{DescriptorStateSpace{T, ET} where ET<:Union{LinearAlgebra.UniformScaling{Bool}, Matrix{T}}, 1}}, Tuple{T}} where T","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.FDIFilterIF","text":"FDIFilterIF(sys; mu = 0, md = 0, mf = 0, mw = 0, ma = 0, moff = 0 ) -> R::FDIFilterIF\n\nBuild for a vector of linear time-invariant descriptor system models sys[i] = (Ai-λEi,Bi,Ci,Di),  a fault detection and isolation filter internal form object R, as determined with the synthesis functions of FDI filters.  mu, md, mf, mw and ma are the dimensions of control, disturbance, fault, noise and auxiliary input vectors, respectively. It is assumed that each Bi = [Boffi Bui Bdi Bfi Bwi Bvi] and Di = [Doffi Dui Ddi Dfi Dwi Dvi] are partitioned matrices such that Boffi and Doffi have moff columns, Bui and Dui have mu columns, Bdi and Ddi have md columns,  Bfi and Dfi have mf columns,  Bwi and Dwi have mw columns, and Bvi and Dvi have ma columns.   \n\nThe resulting R contains the vector of partitioned systems  R.sys[i] = (A-λE,[Bui Bdi Bfi Bwi Bvi],C,[Dui Ddi Dfi Dwi Dvi]) and  the dimensions of control, disturbance, fault, noise and auxiliary input vectors are contained in  R.mu, R.md, R.mf, R.mw and R.ma, respectively.  \n\n\n\n\n\n","category":"method"},{"location":"FDIObjects.html#FaultDetectionTools.fdIFeval","page":"Building fault detection and isolation related objects","title":"FaultDetectionTools.fdIFeval","text":"fdIFeval(sysQ::FDFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDFilterIF\n\nCompute the internal form sysR of the fault detection filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Q(λ) = [ Qy(λ) Qu(λ) ] is the partitioned transfer function matrix of the fault detection filter sysQ  in accordance with the partitioned filter inputs as measurable outputs and control inputs, then  the transfer function matrix R(λ) of the resulting internal form sysR is given by\n\n R(λ) = | Qy(λ)  Qu(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                           |  I       0     0     0     0   |\n\nA minimal descriptor realization is computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ar-λEr,Br,Cr,Dr) is the full order descriptor realization of sysR.sys, then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ar, Br, Cr, Dr, the absolute tolerance for the nonzero elements of Er,   and the relative tolerance for the nonzero elements of Ar, Br, Cr, Dr and Er. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sysR.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nfdIFeval(sysQ::FDIFilter, sysf::FDIModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::FDIFilterIF\n\nCompute the internal form sysR of the fault detection and isolation filter sysQ applied to the synthesis model sysf.  If sysf has the partitioned transfer function matrix G(λ) = [ Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) ] in accordance with the partitioned system inputs as controls, disturbances, faults, noise and auxiliary inputs, respectively, and Qi(λ) = [ Qyi(λ) Qui(λ) ] is the partitioned transfer function matrix of the i-th filter sysQ.sys[i]  in accordance with the partitioned filter inputs as measurable outputs and control inputs, then  the transfer function matrix Ri(λ) of the i-th filter in the resulting internal form sysR.sys[i] is given by\n\n Ri(λ) = | Qyi(λ)  Qui(λ) | * | Gu(λ)  Gd(λ) Gf(λ) Gw(λ) Gv(λ) |\n                              |  I       0     0     0     0   |\n\nMinimal descriptor realizations are computed if minimal = true and a possibly non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Ari-λEri,Bri,Cri,Dri) is the full order descriptor realization of sysR.sys[i], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ari, Bri, Cri, Dri, the absolute tolerance for the nonzero elements of Eri,   and the relative tolerance for the nonzero elements of Ari, Bri, Cri, Dri and Eir. The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the order of the system sysR.sys[i].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#Analysis-of-FDI-synthesis-models","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"","category":"section"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec  Generation of achievable FDI specifications.\nfdichkspec  Feasibility analysis of a set of FDI specifications.","category":"page"},{"location":"FDIanalysis.html","page":"Analysis of FDI synthesis models","title":"Analysis of FDI synthesis models","text":"fdigenspec\nfdichkspec","category":"page"},{"location":"FDIanalysis.html#FaultDetectionTools.fdigenspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdigenspec","text":"S = fdigenspec(sysf::FDIModel; sdeg, FDtol, FDGainTol, FDfreq, atol, atol1, atol2, atol3, rtol, fast = true)\n\nGenerate all achievable specifications S for a given synthesis model sysf with additive faults.  Each row of the resulting binary matrix S contains a nonzero specification (or fault signature) which can be achieved using a linear fault detection filter (e.g., as obtainable with the help of function efdisyn).\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the following default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The Procedure GENSPEC from [1] is implemented.  The nullspace method [2] is recursively employed to generate candidate fault detection and isolation filters, whose internal forms provide the structure matrices corresponding to the achievable weak specifications, if freq = missing,  or strong specifications for the frequencies conatined in freq. The generation method is also described in [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.       Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[3] A. Varga, On computing achievable fault signatures. Proc. SAFEPROCESS'2009, Barcelona, Spain. \n\n\n\n\n\n","category":"function"},{"location":"FDIanalysis.html#FaultDetectionTools.fdichkspec","page":"Analysis of FDI synthesis models","title":"FaultDetectionTools.fdichkspec","text":"fdichkspec(sysf::FDIModel, SFDI::BitMatrix; sdeg, FDtol, FDGainTol, FDfreq, \n             atol, atol1, atol2, atol3, rtol, fast = true, minimal = false) -> (rdims, orders, leastorders)\n\nCheck for a given synthesis model sysf::FDIModel the feasibility of a set of fault detection and isolation specifications SFDI.  If SFDI has N rows (i.e., contains N specifications), then the N-dimensional integer vectors rdims, orders, leastorders  are returned and contain information related to the synthesis of FDI filters to achieve the feasible specifications.  For the i-th specification contained in SFDI[i,:], rdims[i] contains the number of residual  outputs of a minimal nullspace basis based FDI filter which can be used to achieve this specification.  If rdims[i] = 0, then the i-th specification is not feasible. For a feasible i-th specification, orders[i]  contains the order of the minimal nullspace basis based FDI filter which can be used to achieve this specification.  If the i-th specification is not feasible, then orders[i] is set to -1. If minimal = true, leastorders[i] contains the least achievable order for a scalar output FDI filter which can be used   to achieve the i-th specification. If minimal = false or if the i-th specification is not  feasible, then leastorders[i] is set to -1.\n\nFDFreq = freq specifies a vector of real frequency values or a scalar real frquency value for strong detectability checks (default: FDFreq = missing).\n\nFDtol = tol1 specifies the threshold tol1 for assessing weak specifications                       (see also function fditspec) (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for assessing strong specifications,   i.e., the threshold for nonzero frequency responce gains for all frequency values specified in freq (see also function fdisspec) (default: tol2 = 0.01). \n\nThe keyword argument sdeg = β specifies a prescribed stability degree β for the poles of the internally  generated candidate filters, such that the real parts of filters poles must be less than or equal to β, in the continuous-time case, and  the magnitudes of filter poles must be less than or equal to β, in the discrete-time case. If sdeg = missing then no then no stabilization is performed if and FDFreq = missing. If sdeg = missing and FDFreq = freq, then the fllowing default values are employed : β = -0.05, in continuous-time case, and  β = 0.95,  in discrete-time case. \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nMethod: The nullspace method of [1] is successively employed to  determine FDI filters as minimal left nullspace bases which solve  suitably formulated fault detection problems. \n\nReferences:\n\n[1] A. Varga, On computing nullspace bases – a fault detection perspective.        Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#Performance-evaluation-of-FDI-filters","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"","category":"section"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"FDIperformance.html","page":"Performance evaluation of FDI filters","title":"Performance evaluation of FDI filters","text":"fditspec\nfdisspec\nfdiscond\nfdif2ngap\nfdimmperf","category":"page"},{"location":"FDIperformance.html#FaultDetectionTools.fditspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fditspec","text":"S = fditspec(sysr::FDFilterIF; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection filter internal form object sysr::FDFilterIF.   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  For block = false, S is determined as a q x mf  binary matrix (BitMatrix), whose (i,j)-th element is S[i,j] = 1, if the (i,j)-th element of Rf(λ) is  nonzero, and otherwise, S[i,j] = 0.  For block = true, S is determined as a 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of Rf(λ) is nonzero, and otherwise, S[1,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nFor block = false, then, if poleshift = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in Ω is nonzero, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if poleshift = true, M(λ) is chosen such that M(λ)*Rf(λ)  as no poles in Ω and if poleshift = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is nonzero and otherwise S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rf(λ) if block = true or for  each element of Rf(λ) if block = false and the nonzero columns or  elements in each column are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of M(λ)*Rf(λ) if block = true or for  each element of M(λ)*Rf(λ) if block = false and  the full rank of the corresponding system matrix is checked for all frequencies in FDfreq (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\nS = fditspec(sysr::FDIFilterIF; FDfreq = missing, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the global transfer function matrix Rf(λ) of  the transfer channel from the fault inputs to residuals of  a fault detection and isolation filter internal form object sysr::FDIFilterIF.   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  For the evaluation of the strong structure matrix, the structure matrix of the stable  transfer function matrix M(λ)*Rf(λ) is determined, with a M(λ) block-diagonal M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is a suitable square and invertible  transfer function matrix (see below). \n\nFDtol = tol1 specifies an absolute threshold tol1 for the magnitudes of nonzero elements in the system matrices  Bf and Df and is used to determine the weak structure matrix.  Its default value is tol1 = 0.0001*max(1, norm(Bf,1), norm(Df,1)). \n\nFDStol = tol2 specifies an absolute  threshold tol2 for the magnitudes of nonzero elements in the system matrices  Af, Ef, Bf, Cf and Df and is used to determine the strong structure matrix.  Its default value is  tol2 = epsm*max(1, norm(Ef,1), norm(Af,1), norm(Bf,1), norm(Cf,Inf), norm(Df,1))),  where epsm is the working machine precision.\n\nIf FDfreq = missing (default), then S contains the weak structure matrix of Rf(λ).  S is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Rfi(λ) is nonzero, and otherwise, S[i,j] = 0. \n\nIf FDfreq = freq specifies a vector freq of nf real frequencies  which characterize the classes of persistent fault signals, then  for a suitable proper and invertible M(λ) (see below),   S contains the strong structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nS is determined as a N x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the j-th column of Mi(λ)*Rfi(λ) is nonzero for all frequencies in Ω, and otherwise, S[i,j] = 0.  If poleshift = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has no poles in Ω and if poleshift = false (default), Mi(λ) = I is used and an error is issued if any Rfi(λ) has poles in Ω. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,   and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod: For the definition of the structure matrix, see [1]. For the determination of the weak structure matrix, minimal realizations are determined for each column of Rfi(λ) and the nonzero columns are identified  (see Corollary 7.1 of [1]). For the determination of the strong structure matrix, minimal realizations are determined for each column of Mi(λ)*Rfi(λ) and  the full rank of the corresponding system matrix is checked for all frequencies in Ω (see Corollary 7.2 in [1]) (i.e., the lack of zeros in all frequencies in Ω).\n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec.3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdisspec","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdisspec","text":" S = fdisspec(sysr::FDFilterIF, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S of the stable transfer function matrix M(λ)*Rf(λ),  where Rf(λ) is the transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF and   M(λ) is a suitable proper and invertible stabilizing transfer function matrix (see below).   For a filter sysr with q residual outputs and mf fault inputs,  Rf(λ) is the q x mf transfer function matrix of the fault inputs channel with the descriptor system representation sysr.sys[:,sysr.faults] := (Af-lambda*Ef,Bf,Cf,Df). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nFor block = false, then, if stabilize = true, M(λ) is chosen diagonal such that M(λ)*Rf(λ) has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as a q x mf binary matrix, whose (i,j)-th element is S[i,j] = 1,  if the (i,j)-th element of M(λ)*Rf(λ)  evaluated for all frequencies in freq is larger than or equal to tol, and otherwise, S[i,j] = 0.  \n\nFor block = true, then, if stabilize = true, M(λ) is chosen such that M(λ)*Rf(λ)  has only stable poles and if stabilize = false (default), M(λ) = I is used and  an error is issued if Rf(λ) has poles in Ω.  S is determined as an 1 x mf binary matrix, whose (1,j)-th element is S[1,j] = 1,  if the j-th column of M(λ)*Rf(λ) evaluated for all frequencies in Ω is larger than or equal to tol and otherwise, S[1,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Af, Bf, Cf, Df, the absolute tolerance for the nonzero elements of Ef,  the absolute tolerance for the nonzero elements of Cf,    and the relative tolerance for the nonzero elements of Af, Bf, Cf, Df and Ef.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n S = fdisspec(sysr::FDIFilterIF, freq; stabilize = false, FDGainTol = 0.01, \n                 atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute, for a given set of real frequencies freq,   the strong binary structure matrix S  of the stable transfer function matrix M(λ)*Rf(λ), where Rf(λ) is the global  transfer function matrix of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF and   M(λ) is a suitable block-diagonal proper and invertible stabilizing transfer function matrix (see below).   The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where the fault to residual channel of the i-th filter sysr.sys[i][:,sysr.faults]  has qi residual outputs and mf fault inputs, has the descriptor system representation sysr.sys[i][:,sysr.faults] := (Afi-lambda*Efi,Bfi,Cfi,Dfi) and  Rfi(λ) is the corresponding qi x mf transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)].  M(λ) = block-diag(M1(λ), M2(λ), ..., MN(λ)), where Mi(λ) is square and invertible  and chosen such that Mi(λ)Rfi(λ) is stable (see below). \n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent fault signals  (default: freq = 0, i.e., characterizing constant faults). S contains the strong  structure matrix of M(λ)*Rf(λ) with respect to a set of nf complex frequencies Ω, defined as follows:  if f is a real frequency in freq, then the corresponding complex frequency in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts.  \n\nFDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nIf stabilize = true, Mi(λ) is chosen such that Mi(λ)*Rfi(λ) has only stable poles and if stabilize = false (default), Mi(λ) = I is used and an error is issued  if any Rfi(λ) has poles in Ω. \n\nS is determined as a N x mf  binary matrix, whose (i,j)-th element is S[i,j] = 1, if the norm of the  j-th column of Mi(λ)*Rfi(λ) evaluated for all frequencies in Ω  is larger than or equal to tol, and otherwise, S[i,j] = 0. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Afi, Bfi, Cfi, Dfi, the absolute tolerance for the nonzero elements of Efi,  the absolute tolerance for the nonzero elements of Cfi,    and the relative tolerance for the nonzero elements of Afi, Bfi, Cfi, Dfi and Efi.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nMethod: S is evaluated using the definition of the strong structure matrix in [1]. \n\nReferences:\n\n[1] Varga A. Solving Fault Diagnosis Problems - Linear Synthesis Techniques. Springer Verlag, 2017; sec. 3.4.\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdiscond","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdiscond","text":" fdiscond(sysr::FDFilterIF,freq) -> (scond, β, γ)\n\nCompute for the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF the quantities:  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDFilterIF,SFDI,freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition scond (and related quatities β and γ) for the binary structure vector SFDI associated to the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF.  If  Rff(λ) is the transfer function matrix formed of those j-th columns of Rf(λ)  for which SFDI[j] = 1, then:    β - the H∞- index of Rff(λ), γ - the maximum of the columns norms of Rff(λ) and  the fault detection sensitivity condition scond evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDFilterIF, SFDI, freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition vector scond (and related quatities β and γ) for the q × mf binary structure matrix SFDI associated to the stable transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection filter internal form object sysr::FDFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter and  Rfi(λ) is the corresponding transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)]. The i-th element of the vectors scond, β and γ contain the quantities:  β[i] - the H∞- index of the nonzero columns of Rffi(λ), γ - the maximum of the nonzero columns norms of Rfi(λ) and  the correspomding fault detection sensitivity condition scond[i] evaluated as scond[i] := β[i]/γ[i], where Rffi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 1 and  Rfi(λ) is the i-th row of Rf(λ).  It is assumed that for each j such that SFDI[i,j] = 1, the j-th column of Rfi(λ) is nonzero  and  for each j such that SFDI[i,j] = 0, the j-th column of Rfi(λ) is zero.  If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq. \n\n\n\n\n\n fdiscond(sysr::FDIFilterIF, SFDI, freq) -> (scond, β, γ)\n\nCompute the detection and isolation sensitivity condition scond (and related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrix Rf(λ) of the transfer channel from the fault inputs to residuals of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter and  Rfi(λ) is the corresponding transfer function matrix.  The global transfer function matrix Rf(λ) is formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)]. It is assumed that for each j such that SFDI[i,j] = 1, the j-th column of Rfi(λ) is nonzero  and  for each j such that SFDI[i,j] = 0, the j-th column of Rfi(λ) is zero.  The i-th element of the vectors scond, β and γ contain the quantities:  β[i] - the H∞- index of the nonzero columns of Rfi(λ), γ - the maximum of the nonzero columns norms of Rf(λ) and  the fault detection sensitivity condition scond evaluated as scond[i] := β[i]/γ[i].  If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdif2ngap","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdif2ngap","text":" fdif2ngap(sysr::FDFilterIF, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF. For the fault to residual channel of the filter sysr.sys[:,sysr.faults]    with the corresponding transfer function matrix Rf(λ) and  the noise to residual channel of the filter sysr.sys[:,sysr.noise]    with the corresponding transfer function matrix Rw(λ),     β is the H∞- index of Rf(λ), γ is the H∞-norm of Rw(λ) and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if there are no noise inputs and gap = 0 if there are no fault inputs.\n\n\n\n\n\n fdif2ngap(sysr::FDFilterIF, SFDI, freq) -> (gap, β, γ)\n\nCompute the fault-to-noise gap gap (and the related quantities β and γ)  for the stable fault detection filter internal form object sysr::FDFilterIF and the associated binary structure vector SFDI. sysr.sys[:,sysr.faults] is the fault to residual channel of the filter  with the corresponding transfer function matrix Rf(λ) and  sysr.sys[:,sysr.noise] is the noise to residual channel of the filter  with the corresponding transfer function matrix Rw(λ).    If  Rff(λ) is the transfer function matrix formed of those j-th columns of Rf(λ)  for which SFDI[j] = 1 and Rdf(λ) is the transfer function matrix formed of  those j-th columns of Rf(λ) for which SFDI[j] = false, then:    β is the H∞- index of Rff(λ), γ is the H∞-norm of [Rdf(λ) Rw(λ)] and  gap is the fault-to-noise gap evaluated as gap := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq.  gap = ∞ if [Rdf(λ) Rw(λ)] = 0 and gap = 0 if Rff(λ) = 0.\n\n\n\n\n\n  fdif2ngap(sysr::FDFilterIF, SFDI, freq; atol = √ϵ) -> (gap, β, γ)\n\nCompute the fault-to-noise gap  gap (and the related quatities β and γ) for the q × mf binary structure matrix SFDI associated to the stable transfer function matrices Rf(λ) and Rw(λ) of the transfer channels from the fault inputs to residuals and noise inputs to residuals, respectively,  of the fault detection filter internal form object sysr::FDFilterIF.  The i-th element of the vectors gap, β and γ contain the quantities:  β[i] - the H∞- index of Rffi(λ), γ[i] - the H∞-norm of [Rdfi(λ) Rwi(λ)] and  the fault-to-noise gap gap evaluated as gap[i] := β[i]/γ[i], where Rffi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 1 and  Rdfi(λ) is formed of those j-th  columns of the i-th row of Rf(λ) for which S[i,j] = 0.  gap[i] = ∞ if [Rdfi(λ) Rwi(λ)] = 0 and gap[i] = 0 if Rffi(λ) = 0. If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq.  atol is an absolute tolerance for the norms Rwi(λ), such that norm values less than or equal to atol are  considered zero (default:  √ϵ, where ϵ is the working machine precision.)\n\n\n\n\n\n fdif2ngap(sysr::FDIFilterIF, SFDI, freq; atol = √ϵ) -> (gap, β, γ)\n\nCompute the fault-to-noise gap  gap (and the related quatities β and γ) for the N × mf binary structure matrix SFDI associated to the stable global transfer function matrices Rf(λ) and Rw(λ) of the transfer channels from the fault inputs to residuals and noise inputs to residuals, respectively,  of the fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ).    The global transfer function matrices Rf(λ) and Rw(λ) are formed by row concatenation of the  transfer function matrices of the N individual filters, i.e.,  Rf(λ) := [ Rf1(λ); Rf2(λ); ...; RfN(λ)] and  Rw(λ) := [ Rw1(λ); Rw2(λ); ...; RwN(λ)]  Let  Rffi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 1 and let Rdfi(λ) be the transfer function matrix formed of those j-th columns of Rfi(λ)  for which SFDI[i,j] = 0.  The i-th element of the vectors gap, β and γ contain the quantities:  β[i] - the H∞- index of Rffi(λ), γ[i] - the H∞-norm of [Rdfi(λ) Rwi(λ)] and  the fault-to-noise gap gap evaluated as gap[i] := β[i]/γ[i].  gap[i] = ∞ if [Rdfi(λ) Rwi(λ)] = 0 and gap[i] = 0 if Rffi(λ) = 0. If freq is a vector of real frequency values, then β[i] and γ[i] are evaluated over the frequencies contained in freq.  atol is an absolute tolerance for the norms Rwi(λ), such that norm values less than or equal to atol are  considered zero (default:  √ϵ, where ϵ is the working machine precision.)\n\n\n\n\n\n","category":"function"},{"location":"FDIperformance.html#FaultDetectionTools.fdimmperf","page":"Performance evaluation of FDI filters","title":"FaultDetectionTools.fdimmperf","text":" γ = fdimmperf(sysr::FDFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF.  If Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of Rw(λ), if nrmflag = Inf (default) and the  H2-norm of Rw(λ), if nrmflag = 2. The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rw(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF for a given binary structure vector SFDI. If Rf(λ) is the transfer function matrix of the  transfer channel from the fault inputs to residuals sysr.sys[:,sysr.faults] and  Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of [Rdf(λ) Rw(λ)], if nrmflag = Inf (default) and the  H2-norm of [Rdf(λ) Rw(λ)],  if nrmflag = 2, where Rdf(λ) is the transfer function matrix formed by those j-th columns of Rf(λ) for which  SFDI[j] = 0.   The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rdf(λ) Rw(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF for a given binary structure matrix SFDI. If Rf(λ) is the transfer function matrix of the  transfer channel from the fault inputs to residuals sysr.sys[:,sysr.faults] and  Rw(λ) is the transfer function matrix of the transfer channel from the noise inputs to residuals  sysr.sys[:,sysr.noise], then γ is the  H∞-norm of [Rdf(λ) Rw(λ)], if nrmflag = Inf (default) and the  H2-norm of [Rdf(λ) Rw(λ)],  if nrmflag = 2, where Rdf(λ) = .!SFDI .* Rf(λ) (i.e., the element-wise product of .!SFDI and Rf(λ). The value of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rdf(λ) Rw(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation filter internal form object sysr::FDIFilterIF.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of Rwi(λ), if nrmflag = Inf (default)  and the  H2-norm of Rwi(λ), if nrmflag = 2. The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix Rwi(λ) of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF, SFDI[, nrmflag])\n\nCompute the model-matching performance γ of the stable fault detection and isolation  filter internal form object sysr::FDIFilterIF and the associated binary structure matrix SFDI.  The filter sysr consists of N individual FDI filters sysr.sys[i], for i = 1, ..., N, where sysr.sys[i][:,sysr.faults] is the fault to residual channel of the i-th filter  with the corresponding transfer function matrix Rfi(λ) and sysr.sys[i][:,sysr.noise] is the noise to residual channel of the i-th filter  with the corresponding transfer function matrix Rwi(λ). Then,  γ is an N-dimensional vector whose i-th component is the  H∞-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = Inf (default)  or the  H2-norm of [Rfdi(λ) Rwi(λ)], if nrmflag = 2, where Rfdi(λ) is the transfer function matrix whose j-th column is  zero if SFDI[i,j] = 1 and is equal to the j-th column of Rfi(λ) if SFDI[i,j] = 0.  The i-th component of γ is infinite for an unstable filter or if nrmflag = 2 and the transfer function matrix [Rfdi(λ) Rwi(λ)] of a continuous-time system is not strictly proper.\n\n\n\n\n\n γ = fdimmperf(sysr::FDFilterIF, sysref::Union{FDFilterIF,FDIModel}[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection filter internal form object sysr::FDFilterIF with respect to the fault detection reference filter internal form  sysref::FDFilterIF.  If R(λ) is the transfer function matrix of the fault detection filter internal form    sysr.sys and Mr(λ) is the transfer function matrix of the fault detection reference filter internal form    sysref.sys, then γ is the  H∞-norm of R(λ)-Mr(λ), if nrmflag = Inf (default) or the  H2-norm of R(λ)-Mr(λ), if nrmflag = 2. The value of γ is infinite for an unstable difference R(λ)-Mr(λ) or if nrmflag = 2 and the transfer function matrix R(λ)-Mr(λ) of a continuous-time system is not strictly proper. In general, R(λ) and Mr(λ) are partitioned as R(λ) = [ Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) ] and Mr(λ) = [ Mru(λ) Mrd(λ) Mrf(λ) Mrw(λ) Mra(λ) ] in accordance with  the partitioning of the inputs in control inputs, disturbance inputs, fault inputs, noise inputs and auxiliary inputs. Void components of Mr(λ) corresponding to non-void components in R(λ) are assumed to be zero. \n\n\n\n\n\n γ = fdimmperf(sysr::FDIFilterIF, sysref::FDIFilterIF[, nrmflag])\n\nCompute the model-matching performance γ of the fault detection and isolation filter internal form object sysr::FDIFilterIF with respect to the fault detection and isolation reference filter internal form  sysref::FDIFilterIF.  If Ri(λ) is the transfer function matrix of the i-th fault detection and isolation filter internal form    sysr.sys[i] and Mri(λ) is the transfer function matrix of the i-th fault detection and isolation reference filter internal form    sysref.sys[i], then γ is a vector whose i-th component γ[i] is the  H∞-norm of Ri(λ)-Mri(λ), if nrmflag = Inf (default) or the  H2-norm of Ri(λ)-Mri(λ), if nrmflag = 2. The value of γ[i] is infinite for an unstable difference Ri(λ)-Mri(λ) or if nrmflag = 2 and the transfer function matrix Ri(λ)-Mri(λ) of a continuous-time system is not strictly proper. In general, Ri(λ) and Mri(λ) are partitioned as Ri(λ) = [ Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) ] and Mri(λ) = [ Mrui(λ) Mrdi(λ) Mrfi(λ) Mrwi(λ) Mrai(λ) ] in accordance with  the partitioning of the inputs in control inputs, disturbance inputs, fault inputs, noise inputs and auxiliary inputs. Void components of Mri(λ) corresponding to non-void components in Ri(λ) are assumed to be zero. \n\n\n\n\n\n","category":"function"},{"location":"FDDbasics.html#Fault-detection-and-diagnosis-basics","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"","category":"section"},{"location":"FDDbasics.html#Synthesis-models","page":"Fault detection and diagnosis basics","title":"Synthesis models","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The plant models underlying all implemented synthesis methods (also called synthesis models) are linear time-invariant system models, where the faults are equated with special (unknown) disturbance inputs.  An important class of models with additive faults arises when defining the fault signals for two main categories of faults, namely, actuator and sensor faults. Two basic forms of synthesis models are used.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The input-output plant model with additive faults  has the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfy(lambda) = G_u(lambda)mathbfu(lambda) +\nG_d(lambda)mathbfd(lambda) + G_f(lambda)mathbff(lambda) +\nG_w(lambda)mathbfw(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where  mathbfy(lambda), mathbfu(lambda), mathbfd(lambda), mathbff(lambda), and mathbfw(lambda) (with boldface notation), are the Laplace-transformed (in the continuous-time case) or Z-transformed (in the discrete-time case)  p-dimensional system output vector y(t), m_u-dimensional control input vector u(t), m_d-dimensional disturbance vector d(t), m_f-dimensional fault vector f(t) and m_w-dimensional noise vector w(t), respectively, and where G_u(lambda), G_d(lambda), G_f(lambda)   and G_w(lambda) are proper transfer function matrices (TFMs) from the respective inputs to outputs.  Input-output models with additive faults of the above form are useful in formulating various fault diagnosis problems, in deriving general solvability conditions and in describing conceptual synthesis procedures. However, these models are generally not suited for numerical computations, due to the  potentially high sensitivity of polynomial-based model representations.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For computational purposes, instead of the above input-output model with the compound TFM  G_u(lambda)  G_d(lambda)  G_f(lambda)  G_w(lambda) , an equivalent state-space model is used having the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrcl Elambda x(t) = Ax(t) + B_u u(t) + B_d d(t) + B_f f(t) + B_w w(t)    \ny(t) =Cx(t) + D_u u(t) + D_d d(t) +  D_f f(t) + D_w w(t)   \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"with the n-dimensional state vector x(t), where lambda x(t) = dotx(t) or lambda x(t) = x(t+1) depending on the type of the system, continuous- or discrete-time, respectively.  The matrix E is generally invertible and is frequently  taken as E = I_n. Plant models of the above state-space form often arise from the linearization of nonlinear dynamic plant models in specific operation points and for  fixed values of plant parameters. The noise inputs generally  account  for the effects of uncertainties (e.g., inherent  variabilities in operating points and parameters).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"To indicate the input-output equivalence of the two types of models, we use the notation","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" G_u(lambda)  G_d(lambda)  G_f(lambda)  G_w(lambda)  = left beginarrayccccc A-lambda E  B_u  B_d  B_f  B_w   hline\nC  D_u  D_d  D_f  D_w endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"which stays for the following relations between the elements of the two representations:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarraylll G_u(lambda) = C(lambda E-A)^-1B_u+D_u \nG_d(lambda) = C(lambda E-A)^-1B_d+D_d \nG_f(lambda) = C(lambda E-A)^-1B_f + D_f\nG_w(lambda) = C(lambda E-A)^-1B_w + D_w \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The state-space synthesis model underlies the definition of the FDIModel object used in the functions for the synthesis of fault diagnosis filters.","category":"page"},{"location":"FDDbasics.html#Residual-generation","page":"Fault detection and diagnosis basics","title":"Residual generation","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A nonzero fault signal f neq 0 signifies a deviation from the normal behaviour of the plant due to an unexpected event (e.g., physical component failure or supply breakdown). Generally, the occurrence of a fault must be detected as early as possible to prevent further degradation of the plant behaviour. Fault detection and diagnosis (FDD) is concerned with one or more of the following aspects: the detection of the occurrence of any fault (fault detection), the localization of detected faults (fault isolation), the reconstruction of the fault signal (fault estimation) and the classification of the detected faults and determination of their characteristics (fault identification). The later aspect is not addressed in this package. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A FDD system is a device (usually based on a collection of real-time processing algorithms) suitably set-up to fulfill the above tasks.  The main component of any FDD system is the residual generator (or fault detection filter), which produces residual signals grouped in a q-dimensional vector r by processing the available measurements y and the known values of control inputs u. The role of the residual signals is to indicate the presence  or absence of faults, and therefore the residual r must be equal (or close) to zero in the absence of faults and significantly different from zero after a fault occurs.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For decision-making when solving fault detection problems, a suitable measure of the residual magnitude is generated in a scalar evaluation signal theta  (e.g., theta = r), which is then used to set a decision variable, say  iota, as follows: iota= 1, if theta  tau for a detected fault, and iota= 0 if theta leq tau,  for the lack of faults, where tau is a given detection threshold.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For decision-making when solving faul isolation problems, r(t) is generally a structured vector with, say n_b components r^(i)(t), i = 1 ldots n_b, and  theta and iota are n_b-dimensional vectors, with theta_i representing a measure of the magnitude of the i-th residual component (e.g., theta_i = -r^(i)). The i-th component of the binary signature vector iota is set iota_i = 1 or iota_i = 0 corresponding to a fired (i.e, theta_i  tau) or not fired (i.e., theta_i leq tau)  component r^(i)(t), respectively.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A linear residual generator employed in a FDD system  has the input-output form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = Q(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = \nQ_y(lambda)mathbfy(lambda) + Q_u(lambda)mathbfu(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where Q(lambda) = Q_y(lambda)  Q_u(lambda) is the TFM of the filter. For a physically realizable filter,  Q(lambda) must be stable (i.e., with all its poles having negative real parts for a continuous-time system or magnitudes less than one for a discrete-time system). The order of Q(lambda) is the dimension of the state vector of a minimal state-space realization of Q(lambda). The dimension q of the residual vector r(t) depends on the fault diagnosis problem to be solved. The above input-output representation is called the implementation form of the fault detection filter and is the basis of its real-time implementation.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The residual signal r(t) generally depends via the system outputs y(t) of all system inputs u(t), d(t), f(t) and w(t). The internal form of the filter is obtained by replacing in the above equation mathbfy(lambda) by its expression in the synthesis model, and is given by","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = R(lambda)left beginarraycmathbfu(lambda)\nmathbfd(lambda)  mathbff(lambda)  mathbfw(lambda)endarrayright =  \nR_u(lambda)mathbfu(lambda) +\nR_d(lambda)mathbfd(lambda) + \nR_f(lambda)mathbff(lambda) + R_w(lambda)mathbfw(lambda)\n","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R(lambda) =  R_u(lambda) mid  R_d(lambda) mid  R_f(lambda) mid  R_w(lambda) = \nQ(lambda)  left beginarraycccc G_u(lambda)  G_d(lambda)  G_f(lambda)   G_w(lambda) \n         I_m_u  0  0  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a successfully designed filter Q(lambda), all TFMs in the corresponding internal form R(lambda) are  stable, and  fulfil  specific fault diagnosis requirements.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The basic functionality  of a well-designed fault detection filter is to ensure the lack of false alarms, in the case when no faults occurred, and the lack of missed detection of faults, in the case of occurrence of a fault. The first requirement is fulfilled if, in the presence of noise, the signal norm r is  sufficiently small for all possible control, disturbance and noise inputs. The requirement on the lack of missed detections is fulfilled provided r is sufficiently large for any fault of sufficiently large magnitude for all possible control, disturbance and noise inputs.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The fault detection filter in the implementation form underlies the definition of the FDFilter object, while the internal form underlies the definition of the FDFilterIF object. These objects are generated by several synthesis functions. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the isolation of faults, a bank of residual generator filters is employed which is formed by stacking a bank of n_b filters of the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr^(i)(lambda) = Q^(i)(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where the i-th filter Q^(i)(lambda) generates the corresponding i-th residual component  r^(i)(t) (scalar or vector). The internal form of the i-th filter Q^(i)(lambda) is ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr^(i)(lambda) = R^(i)(lambda)left beginarraycmathbfu(lambda)\nmathbfd(lambda)  mathbff(lambda)  mathbfw(lambda)endarrayright =  \nR^(i)_u(lambda)mathbfu(lambda) +\nR^(i)_d(lambda)mathbfd(lambda) + \nR^(i)_f(lambda)mathbff(lambda) + R^(i)_w(lambda)mathbfw(lambda)\n","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R^(i)(lambda) =  R^(i)_u(lambda) mid  R^(i)_d(lambda) mid  R^(i)_f(lambda) mid  R^(i)_w(lambda) = \nQ^(i)(lambda)  left beginarraycccc G_u(lambda)  G_d(lambda)  G_f(lambda)   G_w(lambda) \n         I_m_u  0  0  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"This leads to the following structured residual vector r(t) and block-structured filters Q(lambda) and R(lambda)","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"r(t) = left beginarrayc r^(1)(t) vdots  r^(n_b)(t) endarrayright  \nQ(lambda) = left beginarrayc Q^(1)(lambda) vdots  Q^(n_b)(lambda) endarrayright    R(lambda) = left beginarrayc R^(1)(lambda) vdots  R^(n_b)(lambda) endarray right  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The above bank of fault detection filters is the basis of the definition of the fault detection and isolation object FDIFilter and its internal form FDIFilterIF.","category":"page"},{"location":"FDDbasics.html#Structure-matrix","page":"Fault detection and diagnosis basics","title":"Structure matrix","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Consider R_f(lambda), the TFM from the fault inputs f to residual r in the internal form, and assume R_f(lambda) is an n_btimes m_f block-structured TFM of the form","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R_f(lambda) = left beginarrayccc R^(1)_f_1(lambda) cdots R^(1)_f_m_f(lambda) \nvdots  ddots  vdots \n R^(n_b)_f_1(lambda) cdots R^(n_b)_f_m_f(lambda) endarrayright   ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where the (ij)-th block of R_f(lambda) is defined as ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"R^(i)_f_j(lambda) = Q^(i)(lambda) left beginarrayc G_f_j(lambda)  0 endarrayright ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Here, Q^(i)(lambda) is either the i-th row of the filter Q(lambda), in which case R^(i)_f_j(lambda) is the (ij)-th element of R_f(lambda), or the i-th block row of Q(lambda) corresponding to the i-th filter in a bank of n_b filters.  In both cases, R^(i)_f_j(lambda) describes how the j-th fault f_j influences the i-th (scalar or vector) component of the residual r.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We associate to the block structured R_f(lambda) the n_btimes m_f binary structure matrix S_R_f, whose (ij)-th element is defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayllrll S_R_f(ij) = 1  text if   R^(i)_f_j(lambda) not=0  \nS_R_f(ij) = 0  text if   R^(i)_f_j(lambda) =0  \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"If S_R_f(ij) = 1 then we say that the i-th residual component is sensitive to the j-th fault f_j, while if S_R_f(ij) = 0 then the j-th fault f_j  is decoupled from i-th residual component. The m_f columns of S_R_f are called fault signatures and play a crucial role in the decision making  for fault isolation. Since each nonzero column of S_R_f is associated with the corresponding fault input, fault isolation can be performed by comparing the resulting binary decision vector iota in the FDD system (i.e., the signatures of fired or not fired residual components) with the fault signatures coded in the columns of S_R_f. The rows of S_R_f play an important role in solving FDI synthesis problems and are called specifications. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The above definition of the structure matrix S_R_f is associated with the zero/nonzero blocks of the TFM R_f(lambda) and is also known as the weak structure matrix.  The strong structure matrix is related to the zero/nonzero blocks of the frequency response of R_f(lambda) evaluated for a set of  relevant complex frequencies Omega characterizing the classes of persistent fault inputs. For example, to a real frequency omega which characterizes sinusoidal faults, the corresponding complex frequency in Omega is jomega for a continuous-time system or exp(jomega T_s) for a discrete-time system with sampling time T_s (thus, the null frequency characterizes constant faults). The strong structure matrix is defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayllrll S_R_f(ij) = 1  text if   R^(i)_f_j(lambda_z) not=0   text for all   lambda_z in Omega \nS_R_f(ij) = 0  text if   R^(i)_f_j(lambda_z) = 0  text for any  lambda_z in Omega \nendarray ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the determination of the weak or strong structure matrix  the function fditspec is available. Alternatively, the function fdisspec can be used to determine the strong structure matrix. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault isolation problems, the choice of the desired structure matrix S_R_f is an important aspect. The function fdigenspec allows to compute the maximally achievable structure matrix for a given synthesis model. The function fdichkspec can be employed to check the feasibility of a set of FDI specifications.","category":"page"},{"location":"FDDbasics.html#Fault-diagnosis-problems","page":"Fault detection and diagnosis basics","title":"Fault diagnosis problems","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Six basic fault diagnosis problems are formulated in what follows and their solutions are addressed by the implemented synthesis functions. To fulfill the basic requirement for the lack of false alarms in the presence of arbitrary control and disturbance inputs, for all problems we require that by a suitable choice of a stable fault detection filter Q(lambda), we achieve that  the residual signal r(t) is fully decoupled from the control input u(t) and disturbance input d(t). Thus, the following decoupling conditions must be generally fulfilled:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayll\n  (i)  R_u(lambda) = 0 \n  (ii)  R_d(lambda) = 0 \nendarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Since the effect  of a nonzero  noise input w(t) can usually not be fully decoupled from the residual r(t), an additional requirement is that the influence of the noise signal w(t) is negligible. Thus, the following noise attenuation condition has to be also fulfilled:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayll\n (iv)  R_w(lambda) approx 0  textrmwith  R_w(lambda)  textrmstable\nendarray ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The condition R_w(lambda) approx 0 expresses the requirement  that the transfer gain R_w(lambda) (measured by any suitable norm) can be made arbitrarily small and is intended to avoid missed detections in the presence of noise inputs. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For particular fault diagnosis problems specific requirements on R_f(lambda) have to be additionally fulfilled.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We distinguish between exact and approximate solutions of fault diagnosis problems. The exact problems impose no conditions regarding noise inputs, excepting the stability of R_w(lambda) in the case when w notequiv 0. The approximate problems address the case of nonzero noise inputs by employing special techniques to reduce their effects. For both cases we assume the following general internal form of the filter Q(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"r(lambda) =\nR_u(lambda)mathbfu(lambda) +\nR_d(lambda)mathbfd(lambda)    + R_f(lambda)mathbff(lambda) + R_w(lambda)mathbfw(lambda) ","category":"page"},{"location":"FDDbasics.html#Exact-fault-detection-problem-(EFDP)","page":"Fault detection and diagnosis basics","title":"Exact fault detection problem (EFDP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDP: Determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda) not = 0 j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Condition (iii) expresses the complete fault detectability condition [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The EFDP can be formulated with the stronger requirement that the columns of R_f(lambda) do not vanish for a set of  relevant complex frequencies Omega characterizing the classes of persistent fault inputs:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDP with strong fault detectability:  For a given set of complex frequencies Omega,  determine a stable\tresidual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda_z) not = 0 forall lambda_z in Omega  j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Condition (iii) expresses the complete strong fault detectability condition [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault detection problems, it is important to assess the sensitivity of the residual signal to individual fault components. The assessment of  complete fault detectability can be done by checking   R_f(lambda) _infty -   0, where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" R_f(lambda) _infty - = min_j R_f_j(lambda)_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"is the mathcalH_infty --index defined in [1], as a measure of the degree of complete fault detectability. If  R_f(lambda) _infty -  = 0, then at least one fault component is not detectable in the residual signal r. The assessment of the strong complete fault detectability with respect to a set of frequencies contained in a set Omega comes down to check  R_f_j(lambda_z) neq 0, for forall lambda_z in Omega and for j = 1 ldots m_f. Alternatively, the assessment of strong complete fault detectability can be done by checking   R_f(lambda) _Omega -   0, where","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" R_f(lambda) _Omega - = min_j    inf_lambda_z in Omega R_f_j(lambda_z)_2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"is the (modified) mathcalH_infty --index defined over the frequencies contained in Omega (see [1]). Since nonzero values of  R_f(lambda) _infty - or  R_f(lambda) _Omega - are not invariant to scaling (e.g., when replacing Q(lambda) by alpha Q(lambda)), these quantities are less appropriate to quantitatively assess the degrees of complete detectability.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The function fdhinfminus can be employed to evaluate R_f(lambda) _infty -  and  R_f(lambda) _Omega -. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A performance measure associated to a fault detection filter Q(lambda) which solves the EFDP is a scaling independent measure of the complete fault detectability called the fault sensitivity condition and is defined (over all frequencies) as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" J_1 =    R_f(lambda) _infty -  max_j R_f_j(lambda)_infty ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Similarly, scaling independent measure of the strong complete fault detectability  can be defined over the frequencies contained in the set Omega as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_1 =    R_f(lambda) _Omega -  max_j sup_lambda_z in Omega R_f_j(lambda_z)_2  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"We have that 0  J_1 leq 1 and 0  widetilde J_1 leq 1 and a value of J_1 (or of widetilde J_1) near to 1, indicates nearly equal sensitivities of residual to all fault components, and makes easier the choice of suitable thresholds for fault detection. On contrary, a small value of J_1 (or of widetilde J_1) indicates potential difficulties in detecting some components of the fault vector, due to a very low sensitivity of the residual to these fault components. In such cases, employing fault detection filters with several outputs (q  1) could be advantageous.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the EFDP the function efdsyn is available and for the evaluation of the  fault sensitivity condition the function fdiscond is available. ","category":"page"},{"location":"FDDbasics.html#Exact-fault-detection-and-isolation-problem-(EFDIP)","page":"Fault detection and diagnosis basics","title":"Exact fault detection and isolation problem (EFDIP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EFDIP: Given a structure matrix S, determine a stable \tresidual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  S_R_f = S  textwith  R_f(lambda)  colormagenta textstable \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The condition (iii) expresses the S fault isolability property [1].","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The solution of the EFDIP can be addressed by solving n_b suitably formulated EFDPs. The i-th EFDP arises by reformulating the i-th EFDIP for determining the i-th  filter Q^(i)(lambda) for a structure matrix which is the i-th row of S. This can be accomplished by redefining the fault components corresponding to zero entries in the i-th row of S as additional disturbance inputs to be decoupled in the i-th residual component r^(i)(t).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving fault detection and isolation problems with a targeted structure matrix S, we obtain partitioned filters (see above) and we can define for each individual filter an associated fault sensitivity condition number. Let f^(i) be formed from the subset of faults corresponding to nonzero entries in the i-th row of S and let R_f^(i)^(i)(lambda) be formed from the corresponding columns of R_f^(i)(lambda).  To characterize the  complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S we can define the fault sensitivity condition number of the i-th filter as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_1^(i) =   big R_f^(i)^(i)(lambda) big_infty -  max_j bigR_f_j^(i)(lambda)big_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Similarly, to characterize the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S,  we define the fault condition number of the i-th filter as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_1^(i) =   big R_f^(i)^(i)(lambda) big_Omega -  max_j sup_lambda_z in Omega bigR_f_j^(i)(lambda_z)big_2   ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the EFDIP the function efdisyn is available and for the evaluation of the  fault sensitivity condition the function fdiscond is available. ","category":"page"},{"location":"FDDbasics.html#Approximate-fault-detection-problem-(AFDP)","page":"Fault detection and diagnosis basics","title":"Approximate fault detection problem (AFDP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AFDP: Determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii) R_f_j(lambda) not = 0 j = 1 ldots m_f  textwith  R_f(lambda)  colormagenta textstable \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The performance of a fault detection filter Q(lambda) which solves the AFDP can be characterized by the fault-to-noise gap defined as ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_2 = R_f(lambda) _infty -  R_w(lambda)_infty","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"By convention, J_2 = 0 if  R_f(lambda) _infty - = 0 and J_2 = infty if  R_f(lambda) _infty -  0 and  R_w(lambda) _infty = 0 (e.g., when solving exact synthesis problems without noise inputs).  A finite frequency variant of the above criterion, which allows to address strong fault detectability aspects for a given set Omega of relevant frequencies is","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_2 =  R_f(lambda) _Omega -   R_w(lambda) _infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The higher the value of J_2 (or widetilde J_2), the easier is to choose suitable thresholds to be used for fault detection purposes in the presence of noise. Therefore, the maximization of the above gaps is a valuable goal in improving the fault detection capabilities of the fault diagnosis system in the presence of exogenous noise.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"The value eta = J_2 can be used to determine an estimation of the minimum size delta_fmin of detectable faults, as delta_fmin = delta_w  eta, where, for delta_w is an upper bound on the magnitude of the noise input w(t) (i.e., w  leq delta_w).  The resulting value of delta_fmin can be used to assess the practical usefulness of any solution, and the maximization of the gap J_2 is always a meaningful goal for the synthesis of fault detection filters. Note that J_2 = infty for a filter Q(lambda) solving an EFDP with w equiv 0. ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection filters which solve the AFDP the function afdsyn is available and for the evaluation of the  fault sensitivity condition the function fdif2ngap is available. ","category":"page"},{"location":"FDDbasics.html#Approximate-fault-detection-and-isolation-problem-(AFDIP)","page":"Fault detection and diagnosis basics","title":"Approximate fault detection and isolation problem (AFDIP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let S be a desired n_btimes m_f structure matrix targeted to be achieved by using a structured fault detection filter Q(lambda) with n_b row blocks (see also the formulation of the EFDIP) and let R_f(lambda) be the corresponding n_btimes m_f block-structured TFM. R_f(lambda) can be additively decomposed as R_f(lambda) = widetilde  R_f(lambda) + overline R_f(lambda), where  widetilde  R_f(lambda) and overline R_f(lambda) have the same block structure as R_f(lambda) and have their (ij)-th blocks defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde  R^(i)_f_j(lambda) = S_ijR^(i)_f_j(lambda) quad overline R^(i)_f_j(lambda) = (1-S_ij)R^(i)_f_j(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"To address the approximate fault detection and isolation problem, we will target to enforce for the part widetilde R_f(lambda) of R_f(lambda) the desired structure matrix S, while the part overline R_f(lambda) must (ideally) be negligible.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AFDIP: Given a structure matrix S, determine a stable residual generator Q(lambda) such that","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)   S_widetilde R_f = S  overline R_f(lambda) approx 0 textwith  R_f(lambda)  colormagenta textstable\n  \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"When solving an AFDIP, it is usually attempted to fulfil the stronger requirement that overline R_f(lambda) =  0 (which is equivalent to require S_R_f = S). If this is not feasible, then the above problem is solved.","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a partitioned filter corresponding to a targeted structure matrix S, we can define for the i-th filter component the associated value of the fault-to-noise gap, which  characterizes the noise attenuation properties of the i-th filter. Let f^(i) be formed from the subset of faults corresponding to nonzero entries in the i-th row of S and  let bar f^(i) be formed from the complementary subset of faults corresponding to zero entries in the i-th row of S. If R_f^(i)^(i)(lambda) and R_bar f^(i)^(i)(lambda)  are formed from the columns of R_f^(i)(lambda) corresponding to f^(i) and bar f^(i), respectively, then the fault-to-noise gap of the i-th filter can be defined as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" J_2^(i) =   big R_f^(i)^(i)(lambda) big_infty -  bigbig R_bar f^(i)^(i)(lambda)   R_w^(i)(lambda)bigbig_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For a similar characterization of the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the i-th row of S,  we have","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":" widetilde J_2^(i) =   big R_f^(i)^(i)(lambda) big_Omega -  bigbig R_bar f^(i)^(i)(lambda)   R_w^(i)(lambda)bigbig_infty  ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the AFDIP the function afdisyn is available and for the evaluation of the  fault sensitivity condition the function fdif2ngap is available. ","category":"page"},{"location":"FDDbasics.html#Exact-model-matching-problem-(EMMP)","page":"Fault detection and diagnosis basics","title":"Exact model-matching problem (EMMP)","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let M_r(lambda) be a given qtimes m_f TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = M_r(lambda) mathbff(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Together with the decoupling conditions R_u(lambda) = 0 and R_d(lambda) = 0, the determination of  Q(lambda) involves the solution of a linear matrix equation with rational function coefficients. However, a particular choice of M_r(lambda) may lead to a solution Q(lambda) which is not proper or is unstable or has both these undesirable properties. Therefore, besides determining Q(lambda),  the determination of a suitable updating factor M(lambda) of M_r(lambda) is necessary to ensure the stability of the solution Q(lambda) for R_f(lambda) = M(lambda) M_r(lambda) (and also of R_w(lambda)). This leads to the following formulation of the EMMP:","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"EMMP: Determine a stable residual generator Q(lambda) and a  stable, diagonal, and invertible M(lambda) such that ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  R_f(lambda) = M(lambda)M_r(lambda) \n  (iv) R_w(lambda)  colormagenta textstable \n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A typical choice for M_r(lambda) is an m_f times m_f  diagonal and invertible TFM, which ensures that each residual r_i(t) is influenced only by the fault f_i(t). This would allow the isolation of arbitrary combinations of up to m_f simultaneous faults.  The choice M_r(lambda) = I_m_f targets the solution of an  exact fault estimation problem (EFEP).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the EMMP the function emmsyn is available. This function can also address the solution of the EMMP with more general reference models (e.g., having components from the control inputs and/or disturbance inputs). ","category":"page"},{"location":"FDDbasics.html#Approximate-model-matching-problem-(AMMP}","page":"Fault detection and diagnosis basics","title":"Approximate model-matching problem (AMMP}","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"Let M_r(lambda) be a given qtimes m_f TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"mathbfr(lambda) = M_r(lambda) mathbff(lambda) ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"AMMP: Determine a stable residual generator Q(lambda) and a  stable, diagonal, and invertible M(lambda) such that ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"beginarrayrl (i)  R_u(lambda) = 0  (ii)  R_d(lambda) = 0 \n  (iii)  R_f(lambda) approx M(lambda)M_r(lambda) \n  (iv)  R_w(lambda)  approx 0  textwith  R_w(lambda)  colormagenta textstable\n  endarray","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"A criterion suitable to characterize the solution of approximate model-matching based syntheses is the  residual error norm","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"J_3 = big R(lambda)- M_r(lambda)big_infty2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"where R(lambda) = R_f(lambda) and M_r(lambda) the reference model (possibly updated). For more generality, this criterion can be defined with  R(lambda) =  R_u(lambda) R_d(lambda) R_f(lambda) R_w(lambda) , the resulting internal form, and M_r(lambda) the desired reference model M_r(lambda) =  M_ru(lambda) M_rd(lambda) M_rf(lambda) M_rw(lambda). When applied to the results computed by other synthesis approaches (e.g., to solve the AFDP or AFDIP), this criterion can be formulated as","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"widetilde J_3 = big R_w(lambda)big_infty2 ","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"which corresponds to assume that M(lambda) = I and M_r(lambda) =  R_u(lambda) R_d(lambda) R_f(lambda) 0  (i.e., a perfect matching of control, disturbance and fault channels is always achieved).","category":"page"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"For the synthesis of fault detection and isolation filters which solve the AMMP the function ammsyn is available. This function can also address the solution of the AMMP with more general reference models (e.g., having components from the control inputs, disturbance inputs and noise inputs). For the evaluation of the  model-matching performace the function fdimmperf is available. ","category":"page"},{"location":"FDDbasics.html#References","page":"Fault detection and diagnosis basics","title":"References","text":"","category":"section"},{"location":"FDDbasics.html","page":"Fault detection and diagnosis basics","title":"Fault detection and diagnosis basics","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"FDIObjects.md\",\n          \"FDIanalysis.md\",\n          \"FDIsynthesis.md\",\n          \"FDIperformance.md\",\n          \"FDIutils.md\",\n          \"MDObjects.md\",\n          \"MDsynthesis.md\",\n          \"MDperformance.md\"]\nModule = [\"FaultDetectionTools\"]\nOrder = [:type, :function]","category":"page"},{"location":"MDperformance.html#Performance-evaluation-of-model-detection-filters","page":"Performance evaluation of model detection filters","title":"Performance evaluation of model detection filters","text":"","category":"section"},{"location":"MDperformance.html","page":"Performance evaluation of model detection filters","title":"Performance evaluation of model detection filters","text":"mdspec  Computation of the weak structure matrix.\nmdsspec  Computation of the strong structure matrix.\nmdperf  Computation of the distance-matching performace.\nmdmatch  Computation of the distance-matching performace to a component model.\nmdgap  Computation of the noise gaps.","category":"page"},{"location":"MDperformance.html","page":"Performance evaluation of model detection filters","title":"Performance evaluation of model detection filters","text":"mdspec\nmdsspec\nmdperf\nmdmatch\nmdgap","category":"page"},{"location":"MDperformance.html#FaultDetectionTools.mdspec","page":"Performance evaluation of model detection filters","title":"FaultDetectionTools.mdspec","text":" S = mdspec(sysR::MDFilterIF; cdinp = false, atol, atol1 = atol, atol2 = atol, rtol = 0)\n\nCompute the weak binary structure matrix S  of a collection of model detection filters using the model detection filter internal form object sysR::MDFilterIF.\n\nFor an M × N array of filters sysR, S is an M × N binary array determined as follows.  Let the (i,j)-th component filter sysR.sys[i,j] have the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwith the Laplace- or Z-transformed residual output rij, control inputs u,  disturbance inputs dj, noise inputs wj, and auxiliary inputs vj,   and with Ruij(λ), Rdij(λ), Rwij(λ) and Rvij(λ), the corresponding transfer function matrices.  Then, S[i,j] = 1 if Ruij(λ) is nonzero for cdinp = false (default), or if [Ruij(λs) Rdij(λs)] is nonzero for cdinp = true. Otherwise, S[i,j] = 0.\n\nIf (Arij-λErij,Brij,Crij,Drij) is the descriptor realization of sysR.sys[i,j], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Arij, Brij, Crij, Drij, the absolute tolerance for the nonzero elements of Erij,   and the relative tolerance for the nonzero elements of Arij, Brij, Crij, Drij and Eirj. The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the order of the system matrix of sysR.sys[i,j].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"MDperformance.html#FaultDetectionTools.mdsspec","page":"Performance evaluation of model detection filters","title":"FaultDetectionTools.mdsspec","text":" S = mdsspec(sysR::MDFilterIF, freq; cdinp = false, MDGainTol = 0.01, \n             atol, atol1 = atol, atol2 = atol, rtol = 0, fast = true)\n\nCompute, for a given set of real frequencies freq, the strong binary structure matrix S  of a collection of model detection filters using the model detection filter internal form object sysR::MDFilterIF.\n\nfreq must contain a real frequency value or a vector of nf real frequencies  which characterize the classes of persistent control and disturbance signals  (default: freq = 0, i.e., characterizing constant signals) and defines  the set Ω of complex frequencies which characterize the classes of persistent signals as follows:  if f is a real frequency in freq, then the corresponding complex frequency λ in Ω  is λ := im*f, for a continuous-time system, or λ := exp(im*f*abs(Ts)), for a discrete-time system with sampling-time Ts. \n\nFor an M × N array of filters sysR, S is an M × N binary array determined as follows.  Let the (i,j)-th component filter sysR.sys[i,j] have the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwith the Laplace- or Z-transformed residual output rij, control inputs u,  disturbance inputs dj, noise inputs wj, and auxiliary inputs vj,   and with Ruij(λ), Rdij(λ), Rwij(λ) and Rvij(λ), the corresponding transfer function matrices.  Then, S[i,j] = 1 if Ruij(λs) is nonzero for all λs ∈ Ω and cdinp = false (default), or if [Ruij(λs) Rdij(λs)] is nonzero for all λs ∈ Ω and cdinp = true. Otherwise, S[i,j] = 0.\n\nMDGainTol = tol specifies an absolute  threshold tol for the nonzero magnitudes of  the frequency response gains (default: tol = 0.01). \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default) or  the more reliable SVD-decompositions if fast = false.\n\nIf (Arij-λErij,Brij,Crij,Drij) is the descriptor realization of sysR.sys[i,j], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Arij, Brij, Crij, Drij, the absolute tolerance for the nonzero elements of Erij,   and the relative tolerance for the nonzero elements of Arij, Brij, Crij, Drij and Eirj. The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the order of the system sysR.sys[i,j].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"MDperformance.html#FaultDetectionTools.mdperf","page":"Performance evaluation of model detection filters","title":"FaultDetectionTools.mdperf","text":" mdperf(sysR::MDFilterIF; MDfreq, cdinp = false, rtolinf = 0.00001, \n        offset, atol, atol1 = atol, atol2 = atol, rtol = 0, fast = true) -> (mdgain, fpeak)\n\nCompute the distance-mapping performance of a collection of model detection filters using the model detection filter internal form object sysR::MDFilterIF.   For an M × N array of filters sysR, the M × N arrays of model detection performance gains  mdgain and the corresponding peak frequencies fpeak are determined as follows.  Let the (i,j)-th component filter sysR.sys[i,j] have the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwith the Laplace- or Z-transformed residual output rij, control inputs u,  disturbance inputs dj, noise inputs wj, and auxiliary inputs vj,   and with Ruij(λ), Rdij(λ), Rwij(λ) and Rvij(λ), the corresponding transfer function matrices.  Then, the (i,j)-th performance gain is evaluated as  mdgain[i,j] = ||Ruij(λ)||∞ if cdinp = false (default) or mdgain[i,j] = ||[Ruij(λ) Rdij(λ)]||∞ if cdinp = true  and fpeak[i,j] contains the corresponding peak frequency. \n\nIf MDfreq = ω, where ω is a given vector of real frequency values, then each gain mdgain[i,j] represents the maximum of 2-norm pointwise gains evaluated for all frequencies in ω and  fpeak[i,j] is the corresponding peak frequency.\n\nThe stability boundary offset, β, to be used to assess the finite poles which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite poles having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite pole having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute the H∞-norms.  These algorithms perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true (default) or the more reliable SVD-decompositions if fast = false.\n\nIf (Arij-λErij,Brij,Crij,Drij) is the descriptor realization of sysR.sys[i,j], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Arij, Brij, Crij, Drij, the absolute tolerance for the nonzero elements of Erij,   and the relative tolerance for the nonzero elements of Arij, Brij, Crij, Drij and Eirj. The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the order of the system sysR.sys[i,j].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nThe keyword argument rtolinf = tol specifies the relative accuracy tol to be used  to compute the infinity norms. The default value used is tol = 0.00001.\n\n\n\n\n\n","category":"function"},{"location":"MDperformance.html#FaultDetectionTools.mdmatch","page":"Performance evaluation of model detection filters","title":"FaultDetectionTools.mdmatch","text":"mdmatch(sysQ::MDFilter, sysc::MDModel; MDfreq, minimal = false, rtolinf, offset, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> (mdgain,fpeak,mind)\n\nCompute the distance-mapping performance vector mdgain achieved using the model detection filter object sysQ::MDFilter applied to a component model sysc::MDModel, the corresponding vector of peak frequencies fpeak, and the index mind of the component of mdgain for which the minimum gain value is achieved. \n\nIf the i-th filter sysQ.sys[i] has the transfer function matrix Qi(λ) and  the component model sysc::MDModel has the partitioned transfer function matrix  G(λ) = [Gu(λ)  Gd(λ) Gw(λ) Gv(λ)] in accordance with the partitioned system inputs as controls, disturbances, noise and auxiliary inputs, respectively, then the distance-mapping performance of the i-th filter applied to the given component model is computed as  mdgain[i] = || Ri(λ) ||∞, where Ri(λ)  is the corresponding internal form\n\n Ri(λ) = Qi(λ) * | Gu(λ)  Gd(λ) Gw(λ) Gv(λ) | .\n                 |  I     0     0     0     |\n\nMinimal descriptor realizations are computed for Ri(λ) if minimal = true and a (possibly) non-minimal  realization is determined if minimal = false (default). \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default) or  the more reliable SVD-decompositions if fast = false.\n\nIf (Ari-λEri,Bri,Cri,Dri) is the full order descriptor realization of Ri(λ), then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Ari, Bri, Cri, Dri, the absolute tolerance for the nonzero elements of Eri,   and the relative tolerance for the nonzero elements of Ari, Bri, Cri, Dri and Eir. The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the order of the realitation of Ri(λ).   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"MDperformance.html#FaultDetectionTools.mdgap","page":"Performance evaluation of model detection filters","title":"FaultDetectionTools.mdgap","text":" mdgap(sysR::MDFilterIF; MDfreq, cdinp = false, rtolinf = 0.00001, \n        offset, atol, atol1 = atol, atol2 = atol, rtol = 0, fast = true) -> (gap, β, γ)\n\nCompute the noise gaps performance of a collection of model detection filters using the model detection filter internal form object sysR::MDFilterIF.   For an M × N array of filters sysR, let the (i,j)-th component filter  sysR.sys[i,j] have the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwith the Laplace- or Z-transformed residual output rij, control inputs u,  disturbance inputs dj, noise inputs wj, and auxiliary inputs vj,   and with Ruij(λ), Rdij(λ), Rwij(λ) and Rvij(λ), the corresponding transfer function matrices.  Then, gap, β and γ are M-dimensional vectors, such that the i-th noise gap is evaluated as  gap[i] = β[i]/γ[i], where β[i] = min(||Rij(λ)||∞ for i neq j)  and γ[i] = ||Rwii(λ)||∞.  Rij(λ) is defined as Rij(λ) = Ruij(λ)  if cdinp = false (default)  or Rij(λ) = [Ruij(λ) Rdij(λ)] if cdinp = true.  \n\nIf MDfreq = ω, where ω is a given vector of real frequency values,  then each gain β[i] represents the minimum of  the maximum of 2-norm pointwise gains evaluated for all frequencies in ω.\n\nThe stability boundary offset, β, to be used to assess the finite poles which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite poles having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite pole having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute the H∞-norms.  These algorithms perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true (default) or the more reliable SVD-decompositions if fast = false.\n\nIf (Arij-λErij,Brij,Crij,Drij) is the descriptor realization of sysR.sys[i,j], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Arij, Brij, Crij, Drij, the absolute tolerance for the nonzero elements of Erij,   and the relative tolerance for the nonzero elements of Arij, Brij, Crij, Drij and Eirj. The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the order of the system sysR.sys[i,j].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nThe keyword argument rtolinf = tol specifies the relative accuracy tol to be used  to compute the infinity norms. The default value used is tol = 0.00001.\n\n\n\n\n\n","category":"function"},{"location":"MDanalysis.html#Analysis-of-model-detection-synthesis-models","page":"Analysis of model detection synthesis models","title":"Analysis of model detection synthesis models","text":"","category":"section"},{"location":"MDanalysis.html","page":"Analysis of model detection synthesis models","title":"Analysis of model detection synthesis models","text":"mddist  Computation of distances between component models.\nmddist2c  Computation of pairwise distances between two sets of component models.","category":"page"},{"location":"MDanalysis.html","page":"Analysis of model detection synthesis models","title":"Analysis of model detection synthesis models","text":"mddist\nmddist2c","category":"page"},{"location":"MDanalysis.html#FaultDetectionTools.mddist","page":"Analysis of model detection synthesis models","title":"FaultDetectionTools.mddist","text":" mddist(sysm; MDfreq, cdinp = false, distance = \"nugap\",  rtolinf = 0.00001, \n        offset, atol, atol1 = atol, atol2 = atol, rtol = 0, fast = true) -> (dist, fpeak)\n\nCompute the pairwise distances between the component models of sysm::MDMModel.   If sysm contains N component models, then the resulting dist and fpeak are  N × N real symmetric matrices, whose [i,j]-th elements contain the  distance beetwen the systems sysm.sys[i] and sysm.sys[j], and,  respectively, the corresponding peak frequency for which the value of the computed distance is achieved.   sysm can be alternatively specified as a vector of component synthesis models. \n\nThe i-th component system sysm.sys[i] has a descriptor realization of the form  sysm.sys[i] = (Ai-λEi,Bi,Ci,Di) and the corresponding input-output form is\n\n  yi = Gui(λ)*u + Gdi(λ)*di + Gwi(λ)*wi + Gvi(λ)*vi\n\nwith the Laplace- or Z-transformed plant outputs yi, control inputs u,  disturbance inputs di, noise inputs wi, and auxiliary inputs vi,   and with Gui(λ), Gdi(λ), Gwi(λ) and Gvi(λ), the corresponding transfer function matrices.  \n\nThe distance beetwen the systems sysm.sys[i] and sysm.sys[j] is evaluated as\n\n  dist[i,j] = distf(G1i(λ),G2j(λ)),\n\nwhere distf(⋅,⋅) is a distance function specified via the option parameter distance (see below) and G1i(λ) and G2j(λ) are suitably defined transfer function matrices  via the option parameter cdinp (see below). The corresponding peak frequency fpeak[i,j] is the frequency value for which the distance is achieved.\n\ndistance = job specifies the distance function to be used as follows:\n\njob = \"nugap\"  - use the ν-gap distance ν(G1i(λ),G2j(λ)) defined in [1] (default)\njob = \"inf\"    - use the H∞-norm of the difference (i.e., ||G1i(λ)-G2j(λ)||_∞)\njob = \"2\"      - use the H2-norm of the difference (i.e., ||G1i(λ)-G2j(λ)||_2)\n\nIf cdinp = false (default), then G1i(λ) = Gui(λ) and G2j(λ) = Guj(λ), while if cdinp = true then G1i(λ) = [Gui(λ) Gdi(λ)] and G2j(λ) = [Guj(λ) Gdj(λ)].  If Gdi(λ) has less columns than Gdj(λ), then [Gdi(λ) 0] (with suitably padded zero columns)  is used instead Gdi(λ), while  if Gdi(λ) has more columns than Gdj(λ), then [Gdj(λ) 0] is used instead Gdj(λ).\n\nIf MDfreq = ω, where ω is a vector of real frequency values, then each distance dist[i,j]  is the maximum of pointwise distances evaluated for all frequencies in ω and  the corresponding frequency fpeak[i,j] is the value for which the maximum pointwise distance is achieved.\n\nThe stability boundary offset, β, to be used to assess the finite poles/zeros which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite poles/zeros having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite pole/zeros having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute range and coimage spaces involved in evaluating  the ν-gap or the H∞-norm distances. These algorithms perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of the state-space matrices  Ai, Bi, Ci,Di, Aj, Bj, Cj and Dj, the absolute tolerance for the nonzero elements of Ei and Ej,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the maximum of the orders of the systems sysm.sys[i] and sysm.sys[j].  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol. \n\nThe keyword argument rtolinf = tol specifies the relative accuracy tol to be used  to compute infinity norms. The default value used is tol = 0.00001.\n\nMethod: The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. \n\nReferences:\n\n[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. \n\n\n\n\n\n","category":"function"},{"location":"MDanalysis.html#FaultDetectionTools.mddist2c","page":"Analysis of model detection synthesis models","title":"FaultDetectionTools.mddist2c","text":" mddist2c(sysm1, sysm2; MDfreq, cdinp = false, distance = \"nugap\", \n          rtolinf = 0.00001, offset, atol, atol1 = atol, atol2 = atol, rtol = 0, fast = true) -> (dist, fpeak)\n\nCompute the pairwise distances between two sets of multiple component synthesis models  sysm1::MDMModel and sysm2::MDMModel.   If sysm1 contains N component models and sysm2 contains M component models,  then the resulting dist and fpeak are N × M real matrices, whose [i,j]-th entries contain the  distance beetwen the systems sysm1.sys[i] and sysm2.sys[j], and, respectively,  the corresponding peak frequency for which the value of the computed distance is achieved.   Both sysm1 and  sysm2 can be alternatively specified as vectors of component synthesis models. \n\nThe i-th component system sysm1.sys[i] has a descriptor realization of the form  sysm1.sys[i] = (A1i-λE1i,B1i,C1i,D1i) and the corresponding input-output form is\n\n  y1i = Gu1i(λ)*u + Gd1i(λ)*di + Gw1i(λ)*wi + Gv1i(λ)*vi\n\nwith the Laplace- or Z-transformed plant outputs y1i, control inputs u,  disturbance inputs di, noise inputs wi, and auxiliary inputs vi,   and with Gu1i(λ), Gd1i(λ), Gw1i(λ) and  Gv1i(λ), the corresponding transfer function matrices. Similarly,  the j-th component system sysm2.sys[j] has a descriptor realization of the form  sysm2.sys[j]= (A2j-λE2j,B2j,C2j,D2j) and the corresponding input-output form is\n\n  y2j = Gu2j(λ)*u + Gd2j(λ)*dj + Gw2j(λ)*wj + Gv2j(λ)*vj\n\nwith the Laplace- or Z-transformed plant outputs y2j, control inputs u,  disturbance inputs dj, noise inputs wj, and auxiliary inputs vj,   and with Gu2j(λ), Gd2j(λ), Gw2j(λ) and  Gv2j(λ), the corresponding transfer function matrices. \n\nThe distance beetwen the systems sysm1.sys[i] and sysm2.sys[j] is evaluated as\n\n  dist[i,j] = distf(G1i(λ),G2j(λ)),\n\nwhere distf(⋅,⋅) is a distance function specified via the option parameter distance (see below) and G1i(λ) and G2j(λ) are suitably defined transfer function matrices  via the option parameter cdinp (see below). The corresponding peak frequency fpeak[i,j] is the frequency value for which the distance is achieved.\n\ndistance = job specifies the distance function to be used as follows:\n\njob = \"nugap\"  - use the ν-gap distance ν(G1i(λ),G2j(λ)) defined in [1] (default)\njob = \"inf\"    - use the H∞-norm of the difference (i.e., ||G1i(λ)-G2j(λ)||_∞)\njob = \"2\"      - use the H2-norm of the difference (i.e., ||G1i(λ)-G2j(λ)||_2)\n\nIf cdinp = false (default), then G1i(λ) = Gu1i(λ) and G2j(λ) = Gu2j(λ), while if cdinp = true then G1i(λ) = [Gu1i(λ) Gd1i(λ)] and G2j(λ) = [Gu2j(λ) Gd2j(λ)].  If Gd1i(λ) has less columns than Gd2j(λ), then [Gd1i(λ) 0] (with suitably padded zero columns)  is used instead Gd1i(λ), while  if Gd1i(λ) has more columns than Gd2j(λ), then [Gd2j(λ) 0] is used instead Gd2j(λ).\n\nIf MDfreq = ω, where ω is a vector of real frequency values, then each distance dist[i,j]  is the maximum of pointwise distances evaluated for all frequencies in ω and  the corresponding frequency fpeak[i,j] is the value for which the maximum pointwise distance is achieved.\n\nThe stability boundary offset, β, to be used to assess the finite poles/zeros which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite poles/zeros having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite pole/zeros having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute range and coimage spaces involved in evaluating  the ν-gap or the H∞-norm distances. These algorithms perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of the state-space matrices     A1i, A2j, B1i, B2j, C1i, C2j, D1i and D2j, the absolute tolerance for the nonzero elements of E1i and E2j,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the maximum of the orders of the systems sysm1.sys[i] and sysm2.sys[j].  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol. \n\nThe keyword argument rtolinf = tol specifies the relative accuracy tol to be used  to compute infinity norms. The default value used is tol = 0.00001.\n\nMethod: The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. \n\nReferences:\n\n[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. \n\n\n\n\n\n","category":"function"},{"location":"MDsynthesis.html#Solving-model-detection-problems","page":"Solving model detection problems","title":"Solving model detection problems","text":"","category":"section"},{"location":"MDsynthesis.html","page":"Solving model detection problems","title":"Solving model detection problems","text":"emdsyn  Exact synthesis of model detection filters.\namdsyn  Approximate synthesis of model detection filters.","category":"page"},{"location":"MDsynthesis.html","page":"Solving model detection problems","title":"Solving model detection problems","text":"emdsyn\namdsyn","category":"page"},{"location":"MDsynthesis.html#FaultDetectionTools.emdsyn","page":"Solving model detection problems","title":"FaultDetectionTools.emdsyn","text":"emdsyn(sysm::MDMModel; rdim, MDSelect, nullspace = true, simple = false, minimal = true, \n                       emtest = false, normalize = false, fast = true, \n                       sdeg, smarg, poles, HDesign, MDtol, MDGainTol, MDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol) \n                       -> (Q::MDFilter, R::MDFilterIF, info)\n\nSolve the exact model detection problem (EMDP) for a given multiple synthesis model sysm::MDMModel. The computed stable and proper filter objects Q and R contain the  model detection filter, representing the solution of the EMDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.MDperf, and info.HDesign,  contains additional synthesis related information (see below). \n\nFor a multiple synthesis model sysm containing N stable component models,  the i-th component system sysm.sys[i] has a descriptor realization of the form  sysm.sys[i] = (Ai-λEi,Bi,Ci,Di) and the corresponding input-output form is\n\n  yi = Gui(λ)*u + Gdi(λ)*di + Gwi(λ)*wi + Gvi(λ)*vi\n\nwith the Laplace- or Z-transformed plant outputs yi, control inputs u,  disturbance inputs di, noise inputs wi, and auxiliary inputs vi,   and with Gui(λ), Gdi(λ), Gwi(λ) and  Gvi(λ), the corresponding transfer function matrices. \n\nThe model detection filter object Q, contains in Q.sys the resulting bank of N filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i,  the i-th component (scalar or vector) of the overall residual vector r := [r_1; r_2; ...; r_N].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The dimensions of output and control inputs are contained in the integers   Q.ny and Q.mu, respectively.\n\nThe model detection filter internal form object R, contains R.sys, the resulting array of N × N  internal form of the filters.   The (i,j)-th component filter R.sys[i,j] is in a standard state-space form,  generates the residual signal r_ij, and corresponds to the  input-output form\n\n   r_ij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwhere \n\n   | Ruij(λ) Rdij(λ) Rwij(λ) Raij(λ) | := |Qyi(λ) Qui(λ)]*| Guj(λ) Gdj(λ) Gwj(λ) Gaj(λ) |. \n                                                          |   I    0      0      0      |\n\nThe solution of the EMDP ensures that for the i-th filter, Ruii(λ) = 0, Rdii(λ) = 0, and  [Ruij(λ) Rdij(λ)] neq 0 for j neq i.\n\nVarious user options can be specified via keyword arguments as follows:\n\nMDSelect = ifilt specifies in the vector ifilt the indices of the desired filters to be designed (default: ifilt = 1:N)\n\nIf minimal = true (default), least order filter synthesis is performed to determine  each of the component filters Q.sys[i] for i = 1, ...,N and R.sys[i,j] for i, j = 1, ...,N  while  with minimal = false full order synthesis is performed.  \n\nIf HDesign = H, then H is an N-dimensional array of full row rank or empty design matrices H = [H_1, ..., H_N], where H_i is the design matrix employed for the synthesis of the i-th component filter (default: HDesign = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filter Q.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. The default value of q[i] is chosen as follows: if HDesign = missing or H_i is empty then   q[i] = 1, if minimal = true, or q[i] is the number of the nullspace basis  vectors used for the synthesis of Q.sys [i], if minimal = false;  if  H_i specifies a full row rank design matrix, then q[i] is the row dimension of H_i. \n\nIf emdtest = false (default), only the input channels are used for model detectability tests. If emdtest = true, extended model detectability tests are performed using both control and disturbance input channels.  \n\nMDfreq = ω specifies a vector of real frequency values or a scalar real frequency value for strong model detectability checks (default: MDfreq = missing).\n\nIf nullspace = false (default),  a full-order observer based nullspace basis is  used for the synthesis of the i-th filter whenever the i-th component system has no disturbance inputs. Otherwise, minimal proper nullspace bases are used.  If nullspace = true, minimal proper nullspace bases are used for the synthesis of the model detection filters. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  The orders of the basis vectors employed for the synthesis of the i-th filter are provided in info.deg[i].  If simple = false (default), then no simple bases are computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nMDtol = tol1 specifies the threshold tol1 for model detectability checks    (default: tol1 = 0.0001).\n\nMDGainTol = tol2 specifies the threshold tol2 for strong model detectability checks    (default: tol2 = 0.01). \n\nIf normalize = false (default), the i-th component filter Q.sys[i] is scaled such that the minimum gain of R.sys[i,j] for j = 1, ..., N,   j neq i, is equal to one.  If normalize = true, the standard normalization of component filters is performed to ensure equal gains for R.sys[1,j] and R.sys[j,1].  This option is only possible if ifilt[1] = 1 (see MDSelect).\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true (default) or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of the state-space matrices  Ai, Bi, Ci and Di, the absolute tolerance for the nonzero elements of Ei,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the orders of the system sysm.sys[i].  The keyword argument atol3 is an absolute tolerance for observability tests    (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, MDperf, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an N-dimensional vector, whose i-th component is an integer vector  containing the degrees of the basis vectors of the employed simple nullspace basis for the synthesis of the i-th filter component, if simple = true,  and the degrees of the basis vectors of an equivalent polynomial nullspace basis, if simple = false;\n\ninfo.MDperf is an N × N array containing the resulting distance-mapping performance,  representing  the peak gains of the associated internal representations of  the model detection filters. If the (i,j)-th component filter R.sys[i,j]  has the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nthen, the (i,j)-th performance gain is evaluated as  info.MDperf[i,j] = ||Ruij(λ)||∞ if emdtest = false (default) or  info.MDperf[i,j] = ||[Ruij(λ) Rdij(λ)]||∞ if emdtest = true.   If MDfreq = ω, then each gain info.MDperf[i,j] represents the maximum of 2-norm pointwise gains evaluated for all frequencies in ω.\n\ninfo.HDesign is an N-dimensional vector, whose i-th component  is the design matrix H_i employed for the synthesis of  the i-th model detection filter.\n\nMethod: The Procedure EMD from [1] is implemented to solve  the exact model detection problem. For more details on  the least order synthesis of model detection filters see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, Least order fault and model detection using multi-models.         IEEE CDC'09, Shanghai, China, 2009.\n\n\n\n\n\n","category":"function"},{"location":"MDsynthesis.html#FaultDetectionTools.amdsyn","page":"Solving model detection problems","title":"FaultDetectionTools.amdsyn","text":"amdsyn(sysm::MDMModel; rdim, MDSelect, nullspace = true, simple = false, minimal = true, \n                       emtest = false, normalize = false, fast = true, \n                       sdeg, smarg, poles, HDesign, MDtol, MDGainTol, MDfreq, \n                       epsreg = 0.1, sdegzer, nonstd = 1, rtolinf= 0.0001, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol) \n                       -> (Q::MDFilter, R::MDFilterIF, info)\n\nSolve the approximate model detection problem (AMDP) for a given multiple synthesis model sysm::MDMModel. The computed stable and proper filter objects Q and R contain the  model detection filter, representing the solution of the AMDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.MDperf,  info.MDgap, info.HDesign and info.nonstandard,  contains additional synthesis related information (see below). \n\nFor a multiple synthesis model sysm containing N stable component models,  the i-th component system sysm.sys[i] has a descriptor realization of the form  sysm.sys[i] = (Ai-λEi,Bi,Ci,Di) and the corresponding input-output form is\n\n  yi = Gui(λ)*u + Gdi(λ)*di + Gwi(λ)*wi + Gvi(λ)*vi\n\nwith the Laplace- or Z-transformed plant outputs yi, control inputs u,  disturbance inputs di, noise inputs wi, and auxiliary inputs vi,   and with Gui(λ), Gdi(λ), Gwi(λ) and  Gvi(λ), the corresponding transfer function matrices. \n\nThe model detection filter object Q, contains in Q.sys the resulting bank of N filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i,  the i-th component (scalar or vector) of the overall residual vector r := [r_1; r_2; ...; r_N].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the  measured outputs and control inputs to the i-th residual component.  The dimensions of measured outputs and control inputs are contained in the integers   Q.ny and Q.mu, respectively.\n\nThe model detection filter internal form object R, contains R.sys, the resulting array of N × N  internal form filters.   The (i,j)-th component filter R.sys[i,j] is in a standard state-space form,  generates the residual signal r_ij, and corresponds to the  input-output form\n\n   r_ij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nwhere \n\n   | Ruij(λ) Rdij(λ) Rwij(λ) Raij(λ) | := |Qyi(λ) Qui(λ)]*| Guj(λ) Gdj(λ) Gwj(λ) Gaj(λ) |. \n                                                          |   I    0      0      0      |\n\nThe solution of the AMDP ensures that for the i-th filter, Ruii(λ) = 0, Rdii(λ) = 0,   [Ruij(λ) Rdij(λ)] neq 0 for j neq i, and, additionally, the maximization  of the achieved gaps (see description of info.MDgap). \n\nVarious user options can be specified via keyword arguments as follows:\n\nMDSelect = ifilt specifies in the vector ifilt the indices of the desired filters to be designed (default: ifilt = 1:N)\n\nIf minimal = true (default), least order filter synthesis is performed to determine  each of the component filters Q.sys[i] for i = 1, ...,N and R.sys[i,j] for i, j = 1, ...,N  while  with minimal = false full order synthesis is performed.  \n\nIf HDesign = H, then H is an N-dimensional array of full row rank or empty design matrices H = [H_1, ..., H_N], where H_i is the design matrix employed for the synthesis of the i-th component filter (default: HDesign = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filter Q.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. The default value of q[i] is chosen as follows: if HDesign = missing or H_i is empty then   q[i] = 1, if minimal = true, or q[i] is the number of the nullspace basis  vectors used for the synthesis of Q.sys [i], if minimal = false;  if  H_i specifies a full row rank design matrix, then q[i] is the row dimension of H_i. \n\nIf emdtest = false (default), only the input channels are used for model detectability tests. If emdtest = true, extended model detectability tests are performed using both control and disturbance input channels.  \n\nMDfreq = ω specifies a vector of real frequency values or a scalar real frequency value for strong model detectability checks (default: MDfreq = missing).\n\nIf nullspace = false (default),  a full-order observer based nullspace basis is  used for the synthesis of the i-th filter whenever the i-th component system has no disturbance inputs. Otherwise, minimal proper nullspace bases are used.  If nullspace = true, minimal proper nullspace bases are used for the synthesis of the model detection filters. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  The orders of the basis vectors employed for the synthesis of the i-th filter are provided in info.deg[i].  If simple = false (default), then no simple bases are computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nMDtol = tol1 specifies the threshold tol1 for model detectability checks    (default: tol1 = 0.0001).\n\nMDGainTol = tol2 specifies the threshold tol2 for strong model detectability checks    (default: tol2 = 0.01). \n\nIf normalize = false (default), the i-th component filter Q.sys[i] is scaled such that the minimum gain of R.sys[i,j] for j = 1, ..., N,   j neq i, is equal to one.  If normalize = true, the standard normalization of component filters is performed to ensure equal gains for R.sys[1,j] and R.sys[j,1].  This option is only possible if ifilt[1] = 1 (see MDSelect).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true (default) or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of the state-space matrices  Ai, Bi, Ci and Di, the absolute tolerance for the nonzero elements of Ei,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is ni*ϵ, where ϵ is the working machine epsilon  and ni is the orders of the system sysm.sys[i].  The keyword argument atol3 is an absolute tolerance for observability tests    (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, MDperf, MDgap, HDesign, nonstandard), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an N-dimensional vector, whose i-th component is an integer vector  containing the degrees of the basis vectors of the employed simple nullspace basis for the synthesis of the i-th filter component, if simple = true,  and the degrees of the basis vectors of an equivalent polynomial nullspace basis, if simple = false;\n\ninfo.MDperf is an N × N array containing the resulting distance-mapping performance,  representing  the peak gains of the associated internal representations of  the model detection filters. If the (i,j)-th component filter R.sys[i,j]  has the input-output form\n\n rij = Ruij(λ)*u + Rdij(λ)*dj + Rwij(λ)*wj + Rvij(λ)*vj ,\n\nthen, the (i,j)-th performance gain is evaluated as  info.MDperf[i,j] = ||Ruij(λ)||∞ if emdtest = false (default) or  info.MDperf[i,j] = ||[Ruij(λ) Rdij(λ)]||∞ if emdtest = true.   If MDfreq = ω, then each gain info.MDperf[i,j] represents the maximum of 2-norm pointwise gains evaluated for all frequencies in ω. \n\ninfo.MDgap is an N-dimensional vector of achieved noise gaps, where  the i-th gap is computed as info.MDgap[i] = β[i]/γ[i], where β[i] = min(||Rij(λ)||∞ for i neq j)  and γ[i] = ||Rwii(λ)||∞.  Rij(λ) is defined as Rij(λ) = Ruij(λ)  if emtest = false (default)  or Rij(λ) = [Ruij(λ) Rdij(λ)] if emtest = true. If MDfreq = ω, where ω is a given vector of real frequency values,  then each gain β[i] represents the minimum of the maximum of 2-norm pointwise gains evaluated for all frequencies in ω. \n\ninfo.HDesign is an N-dimensional vector, whose i-th component  is the design matrix H_i employed for the synthesis of  the i-th model detection filter.\n\ninfo.nonstandard is an N-dimensional vector, whose i-th component is true  if the synthesis of the i-th filter involved a nonstandard optimization problem and  is false otherwise.\n\nMethod: An extension of the Procedure AMD from [1] is implemented to solve  the approximate model detection problem. This procedure relies on the nullspace-based synthesis method of model detection filters proposed in [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, Least order fault and model detection using multi-models.         IEEE CDC'09, Shanghai, China, 2009.\n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FDI-related-utilities","page":"FDI related utilities","title":"FDI related utilities","text":"","category":"section"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"FDIutils.html","page":"FDI related utilities","title":"FDI related utilities","text":"fdhinfminus\nfdhinfmax\nfditspec_\nfdisspec_\nfdiscond_","category":"page"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfminus","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfminus","text":" fdhinfminus(sys,freq) -> (β, ind, fr)\n\nCompute for a stable descriptor system sys = (A-λE,B,C,D) the H∞- index β of its transfer function matrix G(λ). If freq = missing (default), then β is the  minimum H∞-norm of the columns of G, ind is the index of the minimum-norm column and fr is  the frequency where the minimum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then β is the minimum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the minimum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdhinfmax","page":"FDI related utilities","title":"FaultDetectionTools.fdhinfmax","text":" fdhinfmax(sys,freq) -> (γ, ind, fr)\n\nCompute for a descriptor system sys = (A-λE,B,C,D), γ - the maximum norm of the columns of its transfer function matrix G(λ). If freq = missing (default), then γ is the  maximum H∞-norm of the columns of G, ind is the index of the maximum-norm column and fr is  the frequency where the maximum H∞-norm of the columns is achieved. If freq is a real value or  a real vector of frequency values, then γ is the maximum of the 2-norms of the columns of the  frequency responses of G evaluated for all values contained in freq, ind is the index of column  for which the maximum is achieved and fr is the corresponding frequency. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fditspec_","page":"FDI related utilities","title":"FaultDetectionTools.fditspec_","text":"S = fditspec_(sysrf::DescriptorStateSpace; FDfreq = missing, block = false, poleshift = false, \n             FDtol, FDStol, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nCompute the weak or strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fditspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdisspec_","page":"FDI related utilities","title":"FaultDetectionTools.fdisspec_","text":" fdisspec_(sysrf::DescriptorStateSpace, freq; block = false, stabilize = false, FDGainTol = 0.01, \n                 atol, atol1, atol2, atol3, rtol, fast = true) -> (S, gains)\n\nCompute the strong binary structure matrix S of the transfer function matrix of a  linear time-invariant system sysrf  (typically representing the transfer channel from the fault inputs to residuals). sysrf has a descriptor system realization of the form sysrf = (Af-lambda*Ef,Bf,Cf,Df)  with a  q x mf transfer function matrix Rf(λ).  For the description of keyword parameters see the documentation of fdisspec. \n\n\n\n\n\n","category":"function"},{"location":"FDIutils.html#FaultDetectionTools.fdiscond_","page":"FDI related utilities","title":"FaultDetectionTools.fdiscond_","text":" fdiscond_(sysrf::DescriptorStateSpace, freq) -> (scond, β, γ)\n\nCompute for a stable descriptor system sysrf = (A-λE,B,C,D) with the transfer function matrix Rf(λ),  β - the H∞- index of Rf(λ), γ - the maximum of the columns norms of Rf(λ) and  scond - the column-gains sensitivity condition evaluated as scond := β/γ.  If freq is a vector of real frequency values, then β and γ are evaluated over the frequencies contained in freq. \n\n\n\n\n\n","category":"function"},{"location":"MDbasics.html#Model-detection-basics","page":"Model detection basics","title":"Model detection basics","text":"","category":"section"},{"location":"MDbasics.html#Synthesis-models","page":"Model detection basics","title":"Synthesis models","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The underlying synthesis techniques of model detection systems rely on multiple-model descriptions of physical fault cases.  The  multiple-model description represents a very general way to describe plant models with various faults. For example, extreme variations of parameters representing the so-called parametric faults, can be easily described by multiple models. Since different degrees of performance degradations of a plant behaviour can be also described via multiple models,   model detection techniques have potentially the capability to address certain fault identification aspects too. Two basic forms of synthesis models are described in what follows.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For physically modelled faults, each fault mode leads to a distinct component model. Assume that we have N stable LTI component models describing the fault-free and faulty systems,  and for j = 1 ldots  N the j-th model  is specified in the input-output form","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"mathbfy^(j)(lambda) =\nG_u^(j)(lambda)mathbfu(lambda)\n+ G_d^(j)(lambda)mathbfd^(j)(lambda)\n+ G_w^(j)(lambda)mathbfw^(j)(lambda) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"where  mathbfy^(j)(lambda), mathbfu(lambda), mathbfd^(j)(lambda) and mathbfw^(j)(lambda) (with boldface notation), are the Laplace-transformed (in the continuous-time case) or Z-transformed (in the discrete-time case) time-dependent vectors, respectively, the measured system output y^(j)(t) in R^p, control input u(t) in R^m_u, disturbance input d^(j)(t) in R^m_d^(j) and noise input w^(j)(t) in R^m_w^(j), and where G_u^(j)(lambda), G_d^(j)(lambda) and G_w^(j)(lambda)  are proper and stable TFMs from the corresponding plant inputs to outputs. In general, the disturbance and noise vectors can have different dimensions for different component systems. ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Important notice: The requirement of stability of the component models is not necessary for the mathematical solution of the model detection problems formulated below. Nevertheless, this requirement  is essential for the practical applicability of model detection techniques, because the detection of    unstable component models is unrealistic in presence of inherent modelling related uncertainties. ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Input-output models of the above form are useful in formulating various model detection problems, in deriving general solvability conditions and in describing conceptual synthesis procedures. However, these models are generally not suited for numerical computations, due to the  potentially high sensitivity of polynomial-based model representations.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For computational purposes, instead of the above input-output model with the j-th compound TFM  G_u^(j)(lambda)  G_d^(j)(lambda)  G_w^(j)(lambda) , equivalent state-space models are used with the j-th model having the form","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayrclE^(j)lambda x^(j)(t) = A^(j)x^(j)(t) + B^(j)_u u(t) + B^(j)_d d^(j)(t) + B^(j)_w w^(j)(t)   \ny^(j)(t) = C^(j)x^(j)(t) + D^(j)_u u(t) + D^(j)_d d^(j)(t) + D^(j)_w w^(j)(t)    endarray ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"where x^(j)(t) in R^n^(j) is the state vector of the j-th system and,  generally, can have different dimensions for different component systems, and   where lambda x^(j)(t) = dotx^(j)(t) or lambda x^(j)(t) = x^(j)(t+1) depending on the type of the system, continuous- or discrete-time, respectively.  Each matrix E^(j) is generally invertible and is frequently  taken as E^(j) = I_n^(j).  The following relations hold between the elements of the two representations:","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarraylll G_u^(j)(lambda) = C^(j)(lambda E^(j)-A^(j))^-1B_u^(j)+D_u^(j) \nG_d^(j)(lambda) = C^(j)(lambda E^(j)-A^(j))^-1B_d^(j)+D_d^(j) \nG_w^(j)(lambda) = C^(j)(lambda E^(j)-A^(j))^-1B_w^(j) + D_w^(j) \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The state-space synthesis models underly the definition of the MDModel and  MDMModelsynthesis model objects used in the functions for the synthesis of model detection filters.","category":"page"},{"location":"MDbasics.html#Residual-generation","page":"Model detection basics","title":"Residual generation","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"A typical model detection system contains a bank of N residual generation filters (or residual generators) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"mathbfr^(i)(lambda) = Q^(i)(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright   i = 1 ldots N","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"where the i-th filter Q^(i)(lambda) generates the corresponding i-th residual component  r^(i)(t) (scalar or vector). The dimension q_i of the residual vector component r^(i)(t) can be chosen always one, but occasionally values q_i  1 may provide better sensitivity to model mismatches.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For decision making, an N-dimensional  evaluation vector theta is employed, whose i-th component theta_i usually represents an approximation of  r^(i)_2, the mathcalL_2- or ell_2-norm of r^(i). Then, an N-dimensional decision vector iota  is built, whose i-th component is set to 0 if theta_i leq tau_i and 1 otherwise, where tau_i is a suitable threshold. The j-th model is detected if iota_j =0 and iota_i =1 for all i not = j. It follows that model detection can be interpreted as a particular type of week fault isolation with N signature vectors, where the N-dimensional j-th signature vector has all elements set to one, excepting the j-th entry which is set to zero. An alternative decision scheme relevant for addressing multiple-model based adaptive control prooblems can also be devised if theta_i is associated with a distance function from the current model to the i-th model. In this case, if j is the index of least component of theta, then setting iota_j =0 and iota_i =1 for all i not = j, the above decision scheme selects that model j which best fits with the current model characterized by the measured input and output data. Moreover, to reduce the real-time computational burden, it is occasionally possible to use a number of filters M, with M ll N.  For example, a single filter (i.e., M = 1) can be sufficient to perform model detection provided the ranges of values of theta_1 for a selected class of persistent test signals correctly reflect the distances from the current model to the first component model.   ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Assuming y(t) = y^(j)(t), the residual signal component r^(i)(t) generally depends on all system inputs u(t), d^(j)(t) and w^(j)(t) via the system output y^(j)(t).  The internal form of the i-th filter driven by the j-th model is obtained by replacing mathbfy(lambda) with mathbfy^(j)(lambda). To make explicit the dependence of r^(i) on the j-th model, we will use widetilde r^(ij), to denote the i-th residual output for the j-th model. After replacing mathbfy(lambda) with mathbfy^(j)(lambda),  we obtain","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarraylrl\nwidetildemathbfr^(ij)(lambda) = R^(ij)(lambda) left beginarraycmathbfu(lambda)  mathbfd^(j)(lambda) mathbfw^(j)(lambda)endarrayright -2mm =\nR_u^(ij)(lambda)mathbfu(lambda) +\nR_d^(ij)(lambda)mathbfd^(j)(lambda) +\nR_w^(ij)(lambda)mathbfw^(j)(lambda)  \nendarray ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"with R^(ij)(lambda) = big R_u^(ij)(lambda) mid R_d^(ij)(lambda) mid R_w^(ij)(lambda)big defined as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"R^(ij)(lambda) =\nQ^(i)(lambda)left beginarrayccc G_u^(j)(lambda)  G_d^(j)(lambda)  G_w^(j)(lambda) \nI_m_u  0  0 endarrayright  ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"This leads to the following structured residual vector r(t) and block-structured filter Q(lambda) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"r(t) = left beginarrayc r^(1)(t) vdots  r^(N)(t) endarrayright  \nQ(lambda) = left beginarrayc Q^(1)(lambda) vdots  Q^(N)(lambda) endarrayright  ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For a successfully designed set of stable and proper filters Q^(i)(lambda), i = 1 ldots N, the corresponding internal representations R^(ij)(lambda) are also a proper and stable.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The above bank of fault detection filters is the basis of the definition of the model detection filter object MDFilter and its internal form MDFilterIF.","category":"page"},{"location":"MDbasics.html#Structure-matrix","page":"Model detection basics","title":"Structure matrix","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"We can associate to the Ntimes N set of TFMs R^(ij)(lambda) the Ntimes N binary structure matrix S_R, whose (ij)-th element is defined as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayllrll S_R(ij) = 1  text if   R_u^(ij)(lambda) not=0  \nS_R(ij) = 0  text if   R_u^(ij)(lambda) =0  \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If S_R(ij) = 1 then we say that the i-th residual component is sensitive to the control inputs of the j-th model, while if S_R(ij) = 0 then the control inputs of the j-th model are decoupled from i-th residual component. The N columns of S_R are called model signatures and play the same role in the decision making as the structure matrices employed for fault isolation. Since each column of S_R is associated with the corresponding model, model detection can be performed by comparing the resulting binary decision vector iota in the model detection system (i.e., the signatures of fired or not fired residual components) with the signatures coded in the columns of S_R. All targeted  model detection signatures have the standard shape below, as for example, for N = 4 ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"S = left beginarraycccc 0  1  1  1 1  0  1  11  1  0  1 1  1  1  0 \nendarray right ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The above definition of the structure matrix S_R can be extended to include the effects of disturbance inputs, by using  big R_u^(ij)(lambda)  R_d^(ij)(lambda) big instead  R_u^(ij)(lambda). This possibility is relevant especially for the cases when there are no control inputs to be actively manipulated. ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The above defined binary matrix is also known as the weak structure matrix associated to the zero/nonozero components of R^(ij)(lambda). We can also define the strong structure matrix, which is related to the zero/nonzero blocks of the frequency response of R^(ij)(lambda) evaluated for a set of  relevant complex frequencies Omega characterizing the classes of persistent input signals. For example, to a real frequency omega which characterizes sinusoidal inputs, the corresponding complex frequency in Omega is jomega for a continuous-time system or exp(jomega T_s) for a discrete-time system with sampling time T_s (thus, the null frequency characterizes constant faults). The strong structure matrix is defined as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayllrll S_R(ij) = 1  text if   R_u^(ij)(lambda_z) not=0   text for all   lambda_z in Omega \nS_R(ij) = 0  text if   R_u^(ij)(lambda_z) = 0  text for any  lambda_z in Omega \nendarray ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the determination of the weak and strong structure matrices the functions  mdspec and  mdsspec are available.  ","category":"page"},{"location":"MDbasics.html#Model-detection-problems","page":"Model detection basics","title":"Model detection problems","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"In this section we formulate the exact and approximate synthesis problems of model detection filters for a collection of N stable LTI systems. As in the case of the EFDIP or AFDIP, we seek N linear residual generators  (or model  detection filters), which process the measurable system outputs y(t) and known control inputs u(t) and generate the N residual signals r^(i)(t)  for i = 1 ldots N. These signals serve for decision-making by comparing the pattern of fired and not fired residuals  with the signatures coded in the columns of the associated standard Ntimes N structure matrix S with zeros on the diagonal and ones elsewhere. The standard requirements for the TFMs of the filters Q^(i)(lambda)  are properness  and stability. For practical purposes, the orders of the filter Q^(i)(lambda) must be as small as possible. Least order filters Q^(i)(lambda) can be usually achieved by employing scalar output filters.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"In analogy to the formulations of the EFDIP and AFDIP, we use the internal form of the i-th residual generator to formulate the basic model detection requirements. Independently of the presence of the noise inputs w^(j), we will target that the i-th residual is exactly decoupled from the i-th model if w^(i) equiv 0 and is sensitive to the j-th model, for all j not = i. These requirements can be easily translated into algebraic conditions using the internal form of the i-th residual generator. We denote widetilde R^(ij)(lambda) alternatively as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"widetilde R^(ij)(lambda) =  R_u^(ij)(lambda)  R_d^(ij)(lambda) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"if both control and disturbance inputs are involved in the model detection, or as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"widetilde R^(ij)(lambda) = R_u^(ij)(lambda) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"if only the control inputs have to be employed for model detection. Then the following conditions have to be always fulfilled for i = 1 ldots N:","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayll\n  (i)   R_u^(ii)(lambda)  R_d^(ii)(lambda) = 0  \n  (ii)  widetilde R^(ij)(lambda) not = 0  forall j not = i   j = 1ldots N  \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Here, (i) is the model decoupling condition for the i-th model in the i-th residual component, while (ii) is the model sensitivity condition of the i-th residual component to all models, excepting the i-th model. In the case when condition (i) cannot be fulfilled (e.g., due to lack of sufficient measurements), some (or even all) components of d^(j)(t) can be redefined as noise inputs and included in w^(j)(t).","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"In what follows, we formulate the exact and approximate model detection problems.","category":"page"},{"location":"MDbasics.html#Exact-model-detection-problem-(EMDP)","page":"Model detection basics","title":"Exact model detection problem (EMDP)","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"EMDP: Determine N stable residual generator filters Q^(i)(lambda) for i = 1 ldots N such that","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayll\n  (i)   R_u^(ii)(lambda)  R_d^(ii)(lambda) = 0  \n  (ii)  widetilde R^(ij)(lambda) not = 0  forall j not = i   j = 1ldots N \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The conditions (i) and (ii) express the model detectability condition [1].","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The EMDP can be formulated with the stronger requirement that widetilde R^(ij)(lambda) do not vanish for a set of  relevant complex frequencies Omega characterizing the classes of persistent inputs:","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"EMDP with strong model detectability:  For a given set of complex frequencies Omega,  determine N stable residual generator filters Q^(i)(lambda) for i = 1 ldots N such that","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayll\n  (i)   R_u^(ii)(lambda)  R_d^(ii)(lambda) = 0  \n  (ii)  widetilde R^(ij)(lambda_z) not = 0 forall lambda_z in Omega  forall j not = i   j = 1ldots N \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The conditions (i) and (ii) express the strong model detectability condition [1].","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the synthesis of model detection filters which solve the EMDP the function emdsyn is available. ","category":"page"},{"location":"MDbasics.html#Approximate-model-detection-problem-(AMDP)","page":"Model detection basics","title":"Approximate model detection problem (AMDP)","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"AMDP: Determine N stable residual generator filters Q^(i)(lambda) for i = 1 ldots N such that","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beginarrayll\n  (i)   R_u^(ii)(lambda)  R_d^(ii)(lambda) = 0  \n  (ii)  widetilde R^(ij)(lambda) not = 0  forall j not = i  j = 1ldots N \n  (iii)  R_w^(ii)(lambda) approx 0  \nendarray","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Here, (iii) is the attenuation condition of the effects of noise inputs.  A similar formulation can be done for the AMDP with strong model detectability.  ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the synthesis of model detection filters which solve the AMDP the function amdsyn is available. ","category":"page"},{"location":"MDbasics.html#Analysis-and-performance-evaluation","page":"Model detection basics","title":"Analysis and performance evaluation","text":"","category":"section"},{"location":"MDbasics.html#Distances-between-models","page":"Model detection basics","title":"Distances between models","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the setup of model detection applications, an important first step is the selection of a representative set of component models to serve for the design of model detection filters. A practical requirement to set up multiple models is to choose a set of component models, such that, each component model is sufficiently far away of the rest of models. A suitable tool to measure the distance between two models is the nu-gap metric introduced in [2]. For two transfer function matrices G_1(lambda) and G_2(lambda) of the same dimensions, we denote delta_nu(G_1(lambda)G_2(lambda)) the  nu-gap metric based distance [2], which generally satisfies 0 leq delta_nu(G_1(lambda)G_2(lambda))leq 1. If delta_nubig(G_1(lambda)G_2(lambda)big) is small, then we can say that G_1(lambda) and G_2(lambda)  are close and it is likely that a model detection filter suited for G_1(lambda) will also work with G_2(lambda), and therefore, one of the two models can be probably removed from the set of component models. On the other side, if delta_nubig(G_1(lambda)G_2(lambda)big)  is nearly equal to 1, then G_1(lambda) and G_2(lambda) are sufficiently distinct, such that an easy discrimination between the two models is possible. If the two models have the same number of outputs but different numbers of inputs, then G_1(lambda) and G_2(lambda) can be suitably padded with zero columns to arrive to a pair with equal number of columns.  ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For a set of N component models, it is useful to determine the pairwise nu-gap distances between the control input channels of the component models by defining the symmetric matrix Delta, whose (ij)-th entry is the nu-gap distance between the transfer function matrices of the i-th and j-th model","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = delta_nubig(G_u^(i)(lambda)G_u^(j)(lambda)big)  ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"It follows that Delta has all its diagonal elements zero. For model detection applications all  off-diagonal elements of Delta must be nonzero, otherwise there are models which can not be potentially discriminated. The above definition of the distances between the i-th and j-th models focuses only on the control input channels. In most of practical applications of the model detection, this is perfectly justified by the fact that, a certain control activity is always necessary, to ensure reliable discrimination among models, independently of the presence or absence of disturbances. However, if the disturbance inputs are relevant to perform model detection (e.g., there are no control inputs), then the definition of Delta can be modified to include the disturbance inputs as well","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = delta_nubig(bigG_u^(i)(lambda)G_d^(i)(lambda)big\nbigG_u^(j)(lambda)G_d^(j)(lambda)bigbig) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Recall that padding with zeros columns may be necessary if G_d^(i)(lambda) and G_d^(j)(lambda) have different number of columns. ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If lambda_k, k = 1 ldots n_f, is a set of n_f frequency values, then we can define the maximum of the point-wise distances","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = max_kdelta_nubig(G_u^(i)(lambda_k)G_u^(j)(lambda_k)big) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"or","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = max_kdelta_nubig(bigG_u^(i)(lambda_k)G_d^(i)(lambda_k)big\nbigG_u^(j)(lambda_k)G_d^(j)(lambda_k)bigbig) ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Besides the nu-gap distance between two transfer function matrices, it is possible to use distances defined in terms of the mathcalH_infty norm or the mathcalH_2 norm of the difference between them:","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":" Delta_ij = bigG_u^(i)(lambda)-G_u^(j)(lambda)big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"or","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = bigG_u^(i)(lambda)-G_u^(j)(lambda)big_2 ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If lambda_k, k = 1 ldots n_f, is a set of n_f frequency values, then, instead of the above norm-based distances, we can use the maximum of the point-wise distances","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Delta_ij = max_kbigG_u^(i)(lambda_k)-G_u^(j)(lambda_k)big_2 ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the evaluation of the above distances between component models the function mddist is available. A second function mddist2c can be employed to compute the pairwise distances between two sets of component models. In particular, this function is usefull to assess the nearness of a current model to the set of component models employed for model detection. ","category":"page"},{"location":"MDbasics.html#Distance-mapping-performance","page":"Model detection basics","title":"Distance mapping performance","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"One of the goals of the model detection is to achieve a special mapping of the distances between N component models using N model detection filters such that the norms of the transfer function matrices R_u^(ij)(lambda)  or of big R_u^(ij)(lambda) R_d^(ij)(lambda)big in the internal forms of the filters qualitatively reproduce the nu-gap distances expressed by the Delta matrix above. The preservation of this distance  mapping property is highly desirable, and the choice of model detection filters must be able to ensure this feature (at least partially for the nearest models).  For example, the choice of the i-th filter Q^(i)(lambda) as a left annihilator  of leftbeginsmallmatrix G_u^(i)(lambda)  G_d^(i)(lambda)  I  0 endsmallmatrixright ensures (see Remark 6.1 of [1]) that the norm of big R_u^(ij)(lambda) R_d^(ij)(lambda)big can be interpreted as a weighted distance between the i-th and j-th component models. It follows that the distance mapping performance of a set of model detection filters Q^(i)(lambda), i = 1 ldots N can be assessed by computing the mapped distance matrix Gamma, whose (ij)-th entry is","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Gamma_ij = big R_u^(ij)(lambda) big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"or, if the disturbance inputs are relevant,","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Gamma_ij = big big R_u^(ij)(lambda) R_d^(ij)(lambda)bigbig_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Using the above choice of the filter Q^(i)(lambda), we have that all diagonal elements of Gamma are zero. Additionally, to guarantee model detectability, any valid design of the model detection filters must guarantee that all off-diagonal elements of Gamma are nonzero. These two properties of Gamma allows to unequivocally identify the exact matching of the current model with one (and only one) of the N component models.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"Two other properties of Gamma are desirable, when solving model detection applications. The first property is the symmetry of Gamma. In contrast to Delta,   Gamma is generally not symmetric, excepting for some particular classes of component models and for special choices of model detection filters. For example, this property can be ensured if all component models are stable and have no disturbance inputs, by choosing Q^(i)(lambda) = big I  -G_u^(i)(lambda)big, in which case R_u^(ij)(lambda) = -R_u^(ji)(lambda). Ensuring the symmetry of Gamma, although very desirable,  is in general difficult to be achieved. In practice, it is often sufficient to ensure via suitable scaling that the gains of first row and first column are equal.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The second desirable property of the mapping Delta_ij rightarrow Gamma_ij is the monotonic mapping property of distances, which is the requirement that for all i and k (i k = 1 ldots N), if Delta_ij  Delta_ik, then Gamma_ij  Gamma_ik. Ensuring this property, makes easier to address model identification problems for which no exact matching between the current model and any one of the component models can be assumed.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If lambda_k, k = 1 ldots n_f, is a given set of n_f frequency values, then, instead of the peak distances, we can use the maximum of the point-wise distances over the finite set of frequency values, to assess the strong model detectability.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the evaluation of the distance mapping performance the function mdperf is available. ","category":"page"},{"location":"MDbasics.html#Distance-matching-performance","page":"Model detection basics","title":"Distance matching performance","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"To evaluate the distance matching property of the model detection filters in the case when no exact matching between the current model and any one of the component models can be assumed, we can define the corresponding current internal forms as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"big widetilde R_u^(i)(lambda) mid widetilde R_d^(i)(lambda) mid widetilde R_w^(i)(lambda)big =\nQ^(i)(lambda)left beginarrayccc widetilde G_u(lambda)  widetilde G_d(lambda)  widetilde G_w(lambda) \nI_m_u  0  0 endarray right","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"and evaluate the mapped distances gamma_i, for i = 1 ldots N, defined as","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"gamma_i = big widetilde R_u^(i)(lambda) big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"or, if the disturbance inputs are relevant,","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"gamma_i = big big  widetilde R_u^(i)(lambda) widetilde R_d^(i)(lambda)bigbig_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The index ell of the smallest value gamma_ell provides (for a well designed set of model detection filters) the index of the best matching component model of the current model.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If lambda_k, k = 1 ldots n_f, is a given set of n_f frequency values, then, instead of the above peak distances, we can use the maximum of the point-wise distances over the finite set of frequency values.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the evaluation of the distance matching performance the function mdmatch is available. ","category":"page"},{"location":"MDbasics.html#Model-detection-noise-gaps","page":"Model detection basics","title":"Model detection noise gaps","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The noise attenuation performance of model detection filters can be characterized via the noise gaps achieved by individual filters. The noise gap for the i-th filter can be defined in terms of the resulting internal forms as the ratio eta_i = beta_igamma_i, where","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beta_i = min_jneq i bigR_u^(ij)(lambda)big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"and","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"gamma_i = bigR_w^(ii)(lambda)big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"The values of beta_i  0, for i = 1 ldots N characterize the model detectability property of the collection of the N component models, while gamma_i characterizes the worst-case influence of noise inputs on the i-th residual component. If gamma_i = 0 (no noise), then eta_i = infty.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If the disturbance inputs are relevant for the model detection, then we can use the following alternative definition of beta_i","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beta_i = min_jneq i bigbigR_u^(ij)(lambda) R_d^(ij)(lambda)bigbig_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"In this case, beta_i  0, for i = 1 ldots N characterize the (extended) model detectability property of the collection of the N component models.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"If lambda_k, k = 1 ldots n_f, is a given set of n_f frequency values, then we can alternatively use the maximum of the point-wise distances over the finite set of frequency values","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beta_i = min_jneq i max_kbigR_u^(ij)(lambda_k)big_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"or","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"beta_i = min_jneq i max_kbigbigR_u^(ij)(lambda_k) R_d^(ij)(lambda_k)bigbig_infty ","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"For the evaluation of the detection noise gaps the function mdgap is available. ","category":"page"},{"location":"MDbasics.html#References","page":"Model detection basics","title":"References","text":"","category":"section"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"MDbasics.html","page":"Model detection basics","title":"Model detection basics","text":"[2]  G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. ","category":"page"},{"location":"MDObjects.html#Building-model-detection-related-objects","page":"Building model detection related objects","title":"Building model detection related objects","text":"","category":"section"},{"location":"MDObjects.html","page":"Building model detection related objects","title":"Building model detection related objects","text":"MDModel  Model detection component synthesis model.\nMDMModel  Model detection multiple synthesis model.\nmdmodset  Setup of multiple synthesis models for solving model detection problems.\nMDFilter  Model detection filter object.\nMDFilterIF  Model detection filter internal form object.\nmdIFeval  Evaluation of the internal forms of model detection filters. ","category":"page"},{"location":"MDObjects.html","page":"Building model detection related objects","title":"Building model detection related objects","text":"MDModel\nMDModel(sys::DescriptorStateSpace; mu, md, mw, ma) \nMDMModel\nMDMModel(sys::Vector{<:DescriptorStateSpace}; mu, md, mw, ma)\nmdmodset\nMDFilter\nMDFilterIF\nmdIFeval","category":"page"},{"location":"MDObjects.html#FaultDetectionTools.MDModel","page":"Building model detection related objects","title":"FaultDetectionTools.MDModel","text":"MDModel <: AbstractFDDObject\n\nType for component synthesis models employed to solve model detection problems.\n\nIf sysc::MDModel is a component synthesis model object, the underlying descriptor system model can be obtained via sysc.sys and the dimensions of the control, disturbance, noise and auxiliary vectors are contained in the integers sysm.mu, sysm.md, sysm.mw and sysm.ma, respectively.\n\n\n\n\n\n","category":"type"},{"location":"MDObjects.html#FaultDetectionTools.MDModel-Tuple{DescriptorStateSpace}","page":"Building model detection related objects","title":"FaultDetectionTools.MDModel","text":"MDModel(sys; mu, md, mw, ma) -> sysc::MDModel\n\nBuild for a linear time-invariant descriptor system sys = (A-λE,B,C,D)  a component synthesis model object sysm::MDModel  to be used in conjunction with the analysis and synthesis functions of model detection filters. \n\nThe resulting synthesis model object sysc contains the component model with partitioned inputs,  sysc.sys = (A-λE,[Bu Bd Bw Bv],C,[Du Dd Dw Dv]), where  Bu, Bd, Bw and Bv are formed from the successive columns of B and are  the input matrices from the control inputs u, disturbance inputs d,  noise inputs w and auxiliary inputs v, respectively,  and Du, Dd, Dw and Dv are formed from the successive columns of D and  are the feedthrough matrices from those inputs. The dimensions of control, disturbance, noise and auxiliary input vectors are contained in  sysm.mu, sysm.md, sysm.mw and sysm.ma, respectively.  \n\nThe information on the partition of the input components  in control, disturbance, noise and auxiliary inputs can be specified using the following keyword arguments:\n\nmu = nu specifies the dimension nu of the control input vector u (default: nu = 0)\n\nmd = nd specifies the dimension nd of the disturbance input vector d (default: nd = 0)\n\nmw = nw specifies the dimension nw of the noise input vector w (default: nw = 0)\n\nma = na specifies the dimension na of the auxiliary input vector v (default: na = 0)\n\n\n\n\n\n","category":"method"},{"location":"MDObjects.html#FaultDetectionTools.MDMModel","page":"Building model detection related objects","title":"FaultDetectionTools.MDMModel","text":"MDMModel <: AbstractFDDObject\n\nType for multiple synthesis models employed to solve model detection problems.\n\nIf sysm::MDMModel is the multiple synthesis model object, the underlying vector of descriptor system models can be obtained via sysm.sys, the common dimension of the control vectors is contained in the integer sysm.mu, and the dimensions of the disturbance, noise  and auxiliary input vectors for the i-th model sysm.sys[i] are contained in the i-th  components of the integer vectors sysm.md, sysm.mw and sysm.ma, respectively.\n\n\n\n\n\n","category":"type"},{"location":"MDObjects.html#FaultDetectionTools.MDMModel-Tuple{Vector{<:DescriptorStateSpace}}","page":"Building model detection related objects","title":"FaultDetectionTools.MDMModel","text":"MDMModel(sys; mu, md, mw, ma) -> sysm::MDMModel\n\nBuild for a vector of linear time-invariant system models sys, with the i-th component model sys[i] = (Ai-λEi,Bi,Ci,Di), a multiple synthesis model object sysm::MDMModel  to be used in conjunction with the analysis and synthesis functions of model detection filters. \n\nThe resulting multiple synthesis model object sysm contains the vector sysm.sys  of component models with partitioned inputs,  with the i-th model sysm.sys[i] = (Ai-λEi,[Bui Bdi Bwi Bvi],Ci,[Dui Ddi Dwi Dvi]), where  Bui, Bdi, Bwi and Bvi are formed from the successive columns of Bi and are  the input matrices from the control inputs u, disturbance inputs di,  noise inputs wi and auxiliary inputs vi, respectively,  and Dui, Ddi, Dwi and Dvi are formed from the successive columns of Di and  are the feedthrough matrices from those inputs. The dimensions of control, disturbance, noise and auxiliary input vectors are contained in  sysm.mu, sysm.md[i], sysm.mw[i] and sysm.ma[i], respectively.  \n\nIf N is the number of component models, the information on the partition of the input components  in control, disturbance, noise and auxiliary inputs can be specified using the following keyword arguments:\n\nmu = nu specifies the dimension nu of control input vector u (default: nu = 0)\n\nmd = nd specifies the vector nd containing the N dimensions of disturbance input vectors, such that           the i-th disturbance vector di has dimension nd[i] (default: nd = zeros(Int,N))\n\nmw = nw specifies the vector nw containing the N dimensions of noise input vectors, such that           the i-th noise vector wi has dimension nw[i] (default: nw = zeros(Int,N))\n\nma = na specifies the vector na containing the N dimensions of auxiliary input vectors, such that           the i-th auxiliary vector vi has dimension na[i] (default: na = zeros(Int,N))\n\n\n\n\n\n","category":"method"},{"location":"MDObjects.html#FaultDetectionTools.mdmodset","page":"Building model detection related objects","title":"FaultDetectionTools.mdmodset","text":"mdmodset(sys; controls, c, disturbances, d, noise, n, aux) -> sysm::MDMModel\n\nBuild for a vector of linear time-invariant system models sys, with the i-th component model  sys[i] = (Ai-λEi,Bi,Ci,Di), a multiple synthesis model object sysm::MDMModel  to be used in conjunction with the analysis and synthesis functions of model detection filters. \n\nThe information on the partition of the input components in control, disturbance, noise and auxiliary inputs can be specified using the following keyword arguments:\n\ncontrols = inpu or c = inpu specifies the indices inpu of the control inputs (default: void)\n\ndisturbances = inpd or d = inpd specifies the indices or a vector of indices inpd of the disturbance inputs (default: void)\n\nnoise = inpn or  noise = inpn specifies the indices or a vector of indices inpn of the noise inputs (default: void)\n\naux = inpa specifies the indices or a vector of indices inpa of the auxiliary inputs (default: void)\n\nThe indices of inputs can be specified as integer vectors, integer scalars or integer UnitRanges. For disturbance, noise and auxiliary inputs, vectors of integer vectors or  vectors of integer UnitRanges can be used to specify possibly different set of indices for each component model.\n\nThe resulting sysm contains the vector sysm.sys of partitioned systems, with the i-th model   sysm.sys[i] = (Ai-λEi,[Bui Bdi Bwi Bvi],Ci,[Dui Ddi Dwi Dvi]), where  Bui, Bdi, Bwi and Bvi are the input matrices from the control inputs u, disturbance inputs di,  noise inputs wi and auxiliary inputs vi, respectively, and Dui, Ddi, Dwi and Dvi are the feedthrough matrices from those inputs. The dimensions of control, disturbance, noise and auxiliary input vectors are contained in  sysm.mu, sysm.md[i], sysm.mw[i] and sysm.ma[i], respectively.  \n\nMethod: If Gi(λ) is the p x mi transfer function matrix of sys[i], then the resulting component system sysm.sys[i] has an  equivalent input output form [Gui(λ) Gdi(λ) Gwi(λ) Gvi(λ)], where the following relations define the component matrices: Gui(λ) = Gi(λ)*Su, Gdi(λ) = Gi(λ)*Sdi,  Gwi(λ) = G(λ)*Swi,  Gvi(λ) = Gi(λ)*Svi, with the selection matrices Su, Sdi, Swi and Svi formed from the columns of the mi-th order identity matrix  (note that Su is the same for all component models). \n\n\n\n\n\nmdmodset(sysc::Vector{<:MDModel}) -> sysm::MDMModel\n\nBuild for a vector of component synthesis models sysc, a multiple synthesis model object sysm::MDMModel  to be used in conjunction with the analysis and synthesis functions of model detection filters. \n\n\n\n\n\n","category":"function"},{"location":"MDObjects.html#FaultDetectionTools.MDFilter","page":"Building model detection related objects","title":"FaultDetectionTools.MDFilter","text":"MDFilter <: AbstractFDDObject\n\nType for model detection filters resulted as solutions of model detection problems.\n\nIf filter::MDFilter is the model detection filter object,  the underlying i-th descriptor system model can be obtained via filter.sys[i] and the dimensions of the partitioned filter input vectors as  measured outputs and control inputs,   can be accessed as the integers contained in filter.ny and filter.mu, respectively.\n\n\n\n\n\n","category":"type"},{"location":"MDObjects.html#FaultDetectionTools.MDFilterIF","page":"Building model detection related objects","title":"FaultDetectionTools.MDFilterIF","text":"MDFilterIF <: AbstractFDDObject\n\nType for the internal form of model detection filters resulted as solutions of model detection problems.\n\nIf filter::MDFilterIF is the model detection filter internal form object,  the underlying (i,j)-th descriptor system model can be obtained via filter.sys[i,j] and the corresponding dimensions of control, disturbance, fault, noise and auxiliary input vectors are contained in  sysm.mu, sysm.md[j], sysm.mw[j] and sysm.ma[j], respectively.  \n\n\n\n\n\n","category":"type"},{"location":"MDObjects.html#FaultDetectionTools.mdIFeval","page":"Building model detection related objects","title":"FaultDetectionTools.mdIFeval","text":"mdIFeval(sysQ::MDFilter, sysm::MDMModel; minimal = false, atol, atol1 = atol, atol2 = atol, rtol, fast = true) -> sysR::MDFilterIF\n\nCompute the internal form sysR of the model detection filter sysQ applied to the multiple synthesis model sysm.  If the j-th component model sysm.sys[j] has the partitioned transfer function matrix Gj(λ) = [ Guj(λ)  Gdj(λ) Gwj(λ) Gvj(λ) ] in accordance with the partitioned system inputs as controls, disturbances, noise and auxiliary inputs, respectively, and Qi(λ) = [ Qyi(λ) Qui(λ) ] is the partitioned transfer function matrix of the i-th filter sysQ.sys[i]  in accordance with the partitioned filter inputs as outputs and controls, then  the transfer function matrix Rij(λ) corresponding to the (i-th filter,j-th model) pair in the resulting internal form sysR.sys[i,j] is given by\n\n Rij(λ) = | Qyi(λ)  Qui(λ) | * | Guj(λ)  Gdj(λ) Gwj(λ) Gvj(λ) |\n                               |  I      0      0      0      |\n\nMinimal descriptor realizations are computed if minimal = true and a (possibly) non-minimal  realization is determined if minimal = false (default). \n\nThe minimal realization computation relies on pencil manipulation algorithms which  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nIf (Arij-λErij,Brij,Crij,Drij) is the full order descriptor realization of sysR.sys[i,j], then  the keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices Arij, Brij, Crij, Drij, the absolute tolerance for the nonzero elements of Erij,   and the relative tolerance for the nonzero elements of Arij, Brij, Crij, Drij and Eirj. The default relative tolerance is nij*ϵ, where ϵ is the working machine epsilon  and nij is the order of the system sysR.sys[i,j].   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#Solving-fault-detection-and-isolation-problems","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"","category":"section"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.\nemmsyn  Exact model-matching based synthesis of fault detection filters.\nammsyn  Approximate model-matching based synthesis of fault detection filters.","category":"page"},{"location":"FDIsynthesis.html","page":"Solving fault detection and isolation problems","title":"Solving fault detection and isolation problems","text":"efdsyn\nefdisyn\nafdsyn\nafdisyn\nemmsyn\nammsyn","category":"page"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdsyn","text":"efdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection problem (EFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.S, and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the EFDP ensures that Ru(λ) = 0, Rd(λ) = 0, and Rf(λ) has all its columns nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting filters Q.sys and R.sys have observable state-space realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf HDesign = H, a full row rank design matrix H is used to build rdim = q  linear combinations of the left nullspace basis vectors (default: HDesign = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  The default value of q is chosen as follows: if HDesign = missing, then   q = 1, if minimal = true, or q is the number of the nullspace basis  vectors used for the initial synthesis, if minimal = false;  if HDesign = H specifies a full row rank design matrix H,  then q is the row dimension of H. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for the synthesis of the fault detection filter. If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, S, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.S is the binary structure matrix corresponding to the computed left nullspace basis;\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter.\n\nMethod: The Procedure EFD from [1] is implemented to solve  the exact fault detection problem. For more details on  the least order synthesis of fault detection filters see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.2.\n\n[2] A. Varga, On computing least order fault detectors using rational nullspace bases.  IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\nefdsyn(sysf::FDIModel, S; rdim, nullspace = true, simple = false, minimal = true, \n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector S.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EFDIP, and its internal form, respectively, and are determined such that R.sys[:,faults] has its j-th column nonzero if S[j] = 1 and the j-th column is zero if S[j] = 0.  For the description of the keyword parameters see the function efdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.efdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.efdisyn","text":"efdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       sdeg, smarg, poles, HDesign, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact fault detection and isolation problem (EFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the EFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs and info.HDesign,  contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the EFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0, and  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero.  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe resulting component filters Q.sys[i] and R.sys[i] have observable state-space realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf HDesign = H, then H is an nb-dimensional array of full row rank or empty design matrices H = [H_1, ..., H_nb], where H_i is the design matrix employed for the synthesis of the i-th component filter (default: HDesign = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. The default value of q[i] is chosen as follows: if HDesign = missing or H_i is empty then   q[i] = 1, if minimal = true, or q[i] is the number of the nullspace basis  vectors used for the synthesis of Q.sys[i] and R.sys[i], if minimal = false;  if  H_i specifies a full row rank design matrix, then q[i] is the row dimension of H_i. \n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  The orders of the basis vectors employed for the synthesis of i-th filter are provided in info.deg[i].  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, HDesign), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.degs is an nb-dimensional vector, whose i-th component is an integer vector  containing the degrees of the basis vectors of the employed simple nullspace basis for the synthesis of the i-th filter component, if simple = true,  and the degrees of the basis vectors of an equivalent polynomial nullspace basis, ifsimple = false`;\n\ninfo.HDesign is an nb-dimensional vector, whose i-th component  is the design matrix H_i employed for the synthesis of  the i-th fault detection filter.\n\nMethod: The Procedure EFDI from [1] is implemented to solve  the exact fault detection and isolation problem.  This procedure relies on the nullspace-based synthesis method proposed in [2]. For more  details on the least order synthesis of fault detection filters see [3].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.4.\n\n[2] A. Varga,  On designing least order residual generators for fault detection      and isolation. 16th International Conference on Control Systems and       Computer Science, Bucharest, Romania, 2007.\n\n[3] A. Varga, On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdsyn","text":"afdsyn(sysf::FDIModel; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                          -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection problem (AFDP) for a given synthesis model sysf with additive faults. The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2,  info.S, info.S2, info.HDesign, info.HDesign2, info.freq and info.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u  ,\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter in internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the AFDP ensures that Ru(λ) = 0, Rd(λ) = 0, Rf(λ) has all its columns nonzero and the H∞-norm of Rw(λ) satisfies ||Rw(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Q(λ) = [ Qy(λ) Qu(λ) ] and R(λ) = [ Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) ]  of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Q(λ) = [ Q1(λ) ] ,   R(λ) = [ R1(λ) ] ,                      (1)\n        [ Q2(λ) ]            [ R2(λ) ]\n\nwhere the filters Q1(λ) and R1(λ) with q1 outputs are the solution of an  AFDP, while the filters Q2(λ) and R2(λ) with q2 outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting filters Q.sys and R.sys have observable state-space  realizations (AQ,BQ,CQ,DQ) and (AQ,BR,CQ,DR), respectively, and thus   share the observable pairs (AQ,CQ). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false a full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, a design matrix H1 of full row rank q1 is used to build q1  linear combinations of the left nullspace basis vectors of  G1(λ) := [ Gu(λ) Gd(λ); I 0]. H1 is used in the synthesis of the components  Q1(λ) and R1(λ) in (1) (default: HDesign = missing).\n\nIf HDesign2 = H2, a design matrix H2 of full row rank q2 is used to build q2  linear combinations of the left nullspace basis vectors of  G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0]. H2 is used in the synthesis of the components  Q2(λ) and R2(λ) in (1) (default: HDesign2 = missing)\n\nrdim = q specifies the desired number q of residual outputs for Q and R.  If rdim = missing, the default value of q is chosen as q = q1 + q2, where  the default values of q1 and q2 are chosen taking into account the rank rw  of Rw(λ) in the reduced system (see [4]), as follows:  if HDesign = missing, then   q1 = min(1,rw), if minimal = true, or q1 = rw, if minimal = false;  if HDesign = H, then q1 is the row dimension of the design matrix H2. if HDesign2 = missing, then   q2 = 1-min(1,rw), if minimal = true, or q2 = nvec-rw, if minimal = false, where nvec is the number of the nullspace basis  vectors used for the initial synthesis (see [1]);  if HDesign2 = H2, then q2 is the row dimension of the design matrix H2.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used for  the initial synthesis of the fault detection filter.  If nullspace = false, a full-order observer based nullspace basis is used.  This option can be only used for a proper system without disturbance inputs. \n\nIf simple = true, a simple proper nullspace basis is emplyed for synthesis.  The orders of the basis vectors employed for the synthesis are provided in info.deg and info.deg2 (see below).  If simple = false (default), then no simple basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\nscale2 = σ2 specifies the scaling factor σ2 to be employed for the components  Q2(λ) and R2(λ) in (1), i.e.,  use  σ2*Q2(λ) and σ2*R2(λ) instead of Q2(λ) and R2(λ).  (default: σ2 is chosen to ensure the minimum gap provided by Q1(λ)) \n\nfreq = val specifies the values of a test frequency to be employed to check the  full row rank admissibility condition (default: randomly generated in the interval (0,1)).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax of  the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\ngamma = γ specifies the allowed upper bound for ∥Rw(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, degs2, S, S2, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G1(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q1(λ) and R1(λ) in (1).\n\ninfo.degs2 is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G2(λ) := [ Gu(λ) Gd(λ) Gw(λ); I 0 0] (also the left Kronecker indices of G2(λ)), if the  state-space realization of [Gu(λ) Gd(λ) Gw(λ)] is minimal.  This information has been used in the case  minimal = true to determine the least order of components Q2(λ) and R2(λ) in (1).\n\ninfo.S is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G1(λ) := [ Gu(λ) Gd(λ); I 0];\n\ninfo.S2 is the binary structure matrix of the reduced system  corresponding to the computed left nullspace basis of G2(λ) := [ Gu(λ) Gd(λ)  Gw(λ); I 0 0];\n\ninfo.HDesign is the design matrix H1 employed for the synthesis of     the components Q1(λ) and R1(λ) in (1) of the fault detection filter;\n\ninfo.HDesign2 is the design matrix H2 employed for the synthesis of  the components Q2(λ) and R2(λ) in (1) of the fault detection filter;\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition;\n\ninfo.gap is the achieved gap ∥Rf(λ)∥∞−/∥Rw(λ)∥∞, where the H−minus index is computed over the whole frequency range, if FDfreq = missing, or over the frequency values contained in freq if FDfreq = freq.\n\nMethod: An extension of the Procedure AFD from [1] is implemented to solve  the approximate fault detection problem (see also [2] and Remark 5.10 of [1]).  The employed regularization approach, based on the modified co-outer-co-inner  factorization, is discussed in [3], see also Remark 5.8 of [1].  For the details of the implemented method, see the documentation of the afdsyn function in [4]. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.3.\n\n[2] A. Varga, General computational approach for optimal fault detection.                Proc. IFAC Symposium SAFEPROCESS, Barcelona, Spain, pp. 107–112, 2009.\n\n[3] K. Glover and A. Varga, On solving non-standard H-/H_2/inf fault detection problems.                Proc. IEEE CDC, Orlando, FL, USA, pp. 891–896, 2011.\n\n[4] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\nafdsyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, exact = false, \n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true)  \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure vector SFDI.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the AFDIP, and its internal form, respectively,  and are determined such that the transfer function matrix of  R.sys[:,faults] has its j-th column nonzero if SFDI[j] = 1.  If the solution of a strong AFDIP is feasible, then the j-th column is zero if SFDI[j] = 0.  If only a the solution of a  weak AFDIP is feasible, then the j-th column may be nonzero if SFDI[j] = 0.  For the description of the keyword parameters see the function afdsyn. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.afdisyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.afdisyn","text":"afdisyn(sysf::FDIModel, SFDI; rdim, nullspace = true, simple = false, minimal = true, separate = false,\n                       gamma = 1, epsreg = 0.1, sdegzer, nonstd = 1, freq, sdeg, smarg, poles, \n                       HDesign, HDesign2, scale2, FDtol, FDGainTol, FDfreq, \n                       tcond, offset, atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate fault detection and isolation problem (AFDIP) for a given synthesis model sysf with additive faults and a given binary structure matrix SFDI with nb rows (specifications).  The computed stable and proper filter objects Q and R contain the  fault detection and isolation filter, representing the solution of the AFDIP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.degs2, info.HDesign,  info.HDesign2 andinfo.gap contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe fault detection and isolation filter object Q, contains in Q.sys the resulting bank of nb filters.  The i-th filter Q.sys[i] is in a standard state-space form and generates r_i, the i-th component (scalar or vector)  of the overall residual vector r := [r_1; r_2; ...; r_nb].  The corresponding input-output (implementation) form of the i-th filter is\n\n        r_i = Qyi(λ)*y + Qui(λ)*u   ,\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the i-th residual component.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter in internal form object R, contains R.sys, the resulting bank of nb  internal form of the filters.   The i-th filter R.sys[i] is in a standard state-space form, which generates the residual signal r_i, and corresponds to the  input-output form\n\n   r_i = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | := |Qyi(λ) Qui(λ)]*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                             |   I     0     0     0     0   |\n\nThe solution of the AFDIP ensures that for the i-th filter, Rui(λ) = 0, Rdi(λ) = 0,  Rfi(λ) has its j-th column nonzero if the (i,j)-th element of SFDI is nonzero,  and the H∞-norm of Rwi(λ) satisfies ||Rwi(λ)||∞ < γ, where the bound γ is  specified via the keyword argument gamma. The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls (void), R.disturbances (void),  R.faults, R.noise and R.aux, respectively.\n\nThe transfer function matrices Qi(λ) := [ Qyi(λ) Qui(λ) ] and Ri(λ) := [ Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) ]  of the i-th components of the resulting filters Q.sys and R.sys, respectively, have, in general, the partitioned forms\n\n Qi(λ) = [ Q1i(λ) ] ,   Ri(λ) = [ R1i(λ) ] ,                      (1)\n         [ Q2i(λ) ]             [ R2i(λ) ]\n\nwhere the filters Q1i(λ) and R1i(λ) with q1i outputs are the solution of an  AFDP, while the filters Q2i(λ) and R2i(λ) with q2i outputs are the solution of an   exact fault detection problem formulated for a reduced system obtained   by decoupling the control and disturbance inputs from the residuals (see [4]).   The overall resulting component filters Q.sys[i] and R.sys[i] have observable state-space  realizations (AQi,BQi,CQi,DQi) and (AQi,BRi,CQi,DRi), respectively, and thus   share the observable pairs (AQi,CQi). \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter synthesis is performed to determine each of the component filters Q.sys[i] and R.sys[i] for i = 1, ...,nb, while  with minimal = false full order synthesis is performed.  \n\nIf exact = true, an exact synthesis (without optimization) is performed, while  with exact = false (default), an approximate synthesis is performed.  \n\nIf HDesign = H1, then H1 is an nb-dimensional array of full row rank or empty design matrices, where H1[i] is the design matrix employed for the synthesis   of the components Q1i(λ) and R1i(λ) in (1) of the i-th filter  (default: HDesign = missing)\n\nIf HDesign2 = H2, then H2 is an nb-dimensional array of full row rank or empty design matrices,  where H2[i] is the design matrix employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of the i-th filter   (default: HDesign2 = missing)\n\nrdim = q specifies the vector q, whose i-th component q[i] specifies  the number of residual outputs for the i-th component filters Q.sys[i] and R.sys[i].  If q is a scalar, then a vector rdim with all components equal to q is assumed. If rdim = missing, the default value of q[i] is chosen as q[i] = q1i + q2i, where  the default values of q1i and q2i are chosen taking into account the rank rwi  of Rwi(λ) in the reduced system (see [2]),  as follows:  if HDesign = missing, then   q1i = min(1,rwi), if minimal = true, or q1i = rwi, if minimal = false;  if HDesign = H1, then q1i is the row dimension of the nonemty design matrix H1[i], or if H1[i] is empty, the above choice for HDesign = missing is employed; if HDesign2 = missing, then   q2i = 1-min(1,rwi), if minimal = true, or q2i is set to its maximum achievable value,  if minimal = false (see [1]);  if HDesign2 = H2, then q2i is the row dimension of the nonemty design matrix H2[i], or  if H2[i] is empty, the above choice for HDesign2 = missing is employed.\n\nFDfreq = freq specifies a vector of real frequency values or a scalar real frequency value for strong detectability checks (default: FDfreq = missing).\n\nIf nullspace = true (default), a minimal proper nullspace basis is used at the  initial reduction step, if separate = false,  or at all synthesis steps, if separate = true. If nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step, if separate = false, or at all synthesis steps, if separate = true. This option can  only be used for a proper system without disturbance inputs. \n\nIf simple = true, simple proper nullspace bases are emplyed for synthesis.  If simple = false (default), then no simple bases are computed. \n\nIf separate = false (default), a two-step synthesis procedure is employed,  where a minimal proper nullspace basis is used at the  initial reduction step.  If separate = true, the filter components are separately determined by solving appropriately formulated fault detection problems. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nFDtol = tol1 specifies the threshold tol1 for fault detectability checks    (default: tol1 = 0.0001).\n\nFDGainTol = tol2 specifies the threshold tol2 for strong fault detectability checks    (default: tol2 = 0.01). \n\nscale2 = σ2 specifies the vector of scaling factors σ2 to be employed for the components  Q2i(λ) and R2i(λ) in (1), i.e.,  use  σ2[i]*Q2i(λ) and σ2[i]*R2i(λ) instead of Q2i(λ) and R2i(λ).  (default: For scale2 = missing, each σ2[i] is chosen to ensure the minimum gap provided by Q1i(λ)) \n\ngamma = γ specifies the allowed upper bound for the resulting ∥Rwi(λ)∥∞ (default: γ = 1).\n\nepsreg = ϵ specifies the value of the regularization parameter ϵ used in afdsyn (default: ϵ = 0.1)\n\nsdegzer = δ specifies the prescribed stability degree δ for zeros shifting    (default: δ = −0.05 for a continuous-time system sysf.sys and     δ = 0.95 for a discrete-time system sysf.sys).\n\nnonstd = job specifies the option to handle nonstandard optimization problems in afdsyn, as follows:\n\n  job = 1 – use the quasi-co-outer–co-inner factorization (default);\n  job = 2 – use the modified co-outer–co-inner factorization with the\n            regularization parameter `ϵ`;\n  job = 3 – use the Wiener-Hopf type co-outer–co-inner factorization;\n  job = 4 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            zero shifting of the non-minimum phase factor using the\n            stabilization parameter `δ`;\n  job = 5 – use the Wiener-Hopf type co-outer-co-inner factorization with\n            the regularization of the non-minimum phase factor using the\n            regularization parameter `ϵ`.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, HDesign, HDesign2, freq, gap), where:\n\ninfo.tcond is an nb-dimensional vector, whose i-th component is the maximum of the condition numbers of the employed  non-orthogonal transformation matrices employed for the synthesis of the i-th filter component;  a warning is issued if any info.tcond[i] >= tcmax;\n\ninfo.HDesign = H1 is an nb-dimensional vector of design matrices,  whose i-th component H1[i] is the design matrix to be employed for the synthesis  of the components Q1i(λ) and R1i(λ) in (1) of  the i-th fault detection filter.\n\ninfo.HDesign2 = H2 is an nb-dimensional vector of design matrices,  whose i-th component H2[i] is the design matrix to be employed for the synthesis  of the components Q2i(λ) and R2i(λ) in (1) of   the i-th fault detection filter.\n\ninfo.freq is the frequency value employed to check the full  row rank admissibility condition.\n\ninfo.gap is an nb-dimensional vector, whose i-th component is the  achieved gap for the synthesis of the i-th filter component.\n\nMethod: The Procedure AFDI from [1] is implemented to solve  the approximate fault detection and isolation problem. For implementation details, see [2].\n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.5.\n\n[2] A. Varga, Fault Detection and Isolation Tools (FDITOOLS) User's Guide,                arXiv:1703.08480. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.emmsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.emmsyn","text":"emmsyn(sysf::FDIModel, sysr::FDFilterIF; nullspace = true, simple = false, minimal = true, regmin = true, normalize = \"gain\", \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the exact model-matching problem (EMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given stable reference filter sysr::FDFilterIF.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing the solution of the EMMP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq  and info.HDesign, contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filter sysr.sys is in a standard or descriptor state-space form sysr.sys = (Ar-λEr,Br,Cr,Dr), which corresponds to the input-output form  \n\n   yr = Mru(λ)*u + Mrd(λ)*d + Mrf(λ)*f + Mrw(λ)*w + Mra(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yr, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mru(λ), Mrd(λ), Mrf(λ), Mrw(λ), and Mra(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrix is considered null. \n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection filter internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = |Qy(λ) Qu(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                     |  I     0     0     0     0    |\n\nThe solution of the standard EMMP is computed if sysr.noise and sysr.aux are void and ensures that Ru(λ) = M(λ)*Mru(λ), Rd(λ) = M(λ)*Mrd(λ) and Rf(λ) = M(λ)*Mrf(λ), where M(λ) is  the transfer function matrix of a stable, diagonal and invertible updating filter returned in info.M.  This filter is determined to guarantee the stability of resulting filters Q and R.   If sysr.noise and sysr.aux are not both void, then  the extended EMMP is solved which additionally ensures Rw(λ) = M(λ)*Mrw(λ) and Ra(λ) = M(λ)*Mra(λ).  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), a least order filter synthesis is performed, while  with minimal = false no least order synthesis is performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case when sysr.controls and sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) such that  Nl(λ)*[Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing  Nl(λ) a minimal left nullspace basis of G(λ) = [Gu(λ) Gd(λ); I 0 ].  \n\nIf HDesign = H is a full row rank design matrix, then H*Nl(λ) is used  instead Nl(λ) (default: HDesign = missing).\n\nAn initial reduction step is performed using the nullspace-based approach (see [1])  if sysr.controls, sysr.disturbances, sysr.noise and sysr.aux are void and minimal = false. In this case,   if nullspace = true (default), a minimal proper nullspace basis is used at the initial reduction step, while, if nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step. This later option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if any of sysr.controls, sysr.disturbances, sysr.noise or sysr.aux is non-void or if minimal = true \n\nIf simple = true, a simple proper nullspace basis Nl(λ)  is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrix M(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation (default);\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is the employed stable and invertible updating filter used to solve the EMMP,  with a diagonal transfer function matrix M(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter Q; H = missing if no design matrix was involved.\n\nMethod: The synthesis Procedures EMM and EMMS from [1] are implemented.   Procedure EMM relies on the model-matching synthesis method proposed in    [2], while Procedure EMMS uses the inversion-based method proposed in [3].    Procedure EMM is generally employed, unless a strong exact fault    detection and isolation problem (strong EFDIP) is solved, in   which case Procedure EMMS is used. \n\nThe strong EFDIP corresponds to the choice of the reference filter sysr such that   Mru(λ) = 0, Mrd(λ) = 0, Mrf(λ) is invertible, Mrw(λ) = 0 and Mra(λ) = 0.    In this case, only the indices of fault inputs sysr.faults must be specified   and the indices of the rest of inputs must be void.    The solution of a fault estimation problem can be targeted by   choosing Mrf(λ) = I and checking that the resulting info.M = I. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, New computational approach for the design of fault       detection and isolation filters.        In M. Voicu (Ed.), \"Advances in Automatic Control\", vol. 754 of        The Kluwer International Series in Engineering and Computer Science,        Kluwer Academic Publishers, pp. 367-381, 2003.\n\n[3] A. Varga. New computational paradigms in solving fault detection        and isolation problems. Annual Reviews in Control, 37:25–42, 2013. \n\n\n\n\n\nemmsyn(sysf::FDIModel, sysr::FDIFilterIF; nullspace = true, simple = false, minimal = true, regmin = true, normalize = \"gain\", \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDIFilter, R::FDIFilterIF, info)\n\nSolve the exact model-matching problem (EMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given bank of stable reference filters sysr::FDIFilterIF.  The computed stable and proper filter objects Q and R contain the  bank of fault detection filters,  representing the component-wise solution of the EMMP, and  their internal forms, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq  and info.HDesign, contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filters packed in sysr  are in a standard or descriptor state-space form, where the i-th filter  sysr.sys[i] = (Ari-λEri,Bri,Cri,Dri) corresponds to the input-output form  \n\n   yri = Mrui(λ)*u + Mrdi(λ)*d + Mrfi(λ)*f + Mrwi(λ)*w + Mrai(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yri, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mrui(λ), Mrdi(λ), Mrfi(λ), Mrwi(λ), and Mrai(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrices are considered null. \n\nThe fault detection and isolation filter object Q, contains in its i-th  component Q.sys[i] the resulting filter  in a standard state-space form, which generates the i-th component  ri of the residual signal.  The corresponding input-output (implementation) form is\n\n        ri = Qyi(λ)*y + Qui(λ)*u\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nThe fault detection and isolation filter internal form object R,  contains in its i-th component R.sys[i], the resulting  internal form of the filter  in a standard state-space form,  which generates the i-th component ri of residual signal , and corresponds to the  input-output form\n\n   ri = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | = |Qyi(λ) Qui(λ)|*| Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |. \n                                                            |  I     0     0     0     0    |\n\nThe component-wise solution of the standard EMMP is computed if sysr.noise and sysr.aux are void and ensures that Rui(λ) = Mi(λ)*Mrui(λ), Rdi(λ) = Mi(λ)*Mrdi(λ) and Rfi(λ) = Mi(λ)*Mrfi(λ), where Mi(λ) is  the transfer function matrix of a stable, diagonal and invertible updating filter returned in the i-th component of the vector info.M.  This filter is determined to guarantee the stability of the i-th components of resulting filters Q and R.   If sysr.noise and sysr.aux are not both void, then  the extended EMMP is component-wise solved which additionally ensures Rwi(λ) = Mi(λ)*Mrwi(λ) and Rai(λ) = Mi(λ)*Mrai(λ).  The indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf minimal = true (default), least order filter syntheses are performed, while  with minimal = false no least order synthesis are performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case when sysr.controls and sysr.disturbances are void with the selection of a least order left annihilator Nl(λ) such that  Nl(λ)*[Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing  Nl(λ) a minimal left nullspace basis of G(λ) = [Gu(λ) Gd(λ); I 0 ].  \n\nIf HDesign = H is a vector of full row rank design matrices,  then H[i]*Nl(λ) is used  instead Nl(λ) for the synthesis of the i-th filter (default: HDesign = missing).\n\nAn initial reduction step is performed using the nullspace-based approach (see [1])  if sysr.controls, sysr.disturbances, sysr.noise and sysr.aux are void and minimal = false. In this case,   if nullspace = true (default), a minimal proper nullspace basis is used at the initial reduction step, while, if nullspace = false, a full-order observer based nullspace basis is used at the  initial reduction step. This later option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if any of sysr.controls, sysr.disturbances, sysr.noise or sysr.aux is non-void or if minimal = true \n\nIf simple = true, a simple proper nullspace basis Nl(λ)  is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrices Mi(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation (default);\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms.\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is a vector of descriptor systems, whose i-th system info.M[i]  contains the employed stable and invertible updating filter used to solve  the i-th EMMP, with a diagonal transfer function matrix Mi(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is a vector of design matrices H, where H[i] is the design matrix  employed for the synthesis of the i-th component of the fault detection filter Q;  H[i] is an empty matrix if no design matrix was involved.\n\nMethod: The synthesis Procedures EMM and EMMS from [1] are used  to determine the component filters.   Procedure EMM relies on the model-matching synthesis method proposed in    [2], while Procedure EMMS uses the inversion-based method proposed in [3].    Procedure EMM is generally employed, unless a strong exact fault    detection and isolation problem (strong EFDIP) is solved, in   which case Procedure EMMS is used. \n\nThe strong EFDIP corresponds to the choice of each component of the bank of    reference filters sysr such that   Mrui(λ) = 0, Mrdi(λ) = 0, Mrfi(λ) is invertible, Mrwi(λ) = 0 and Mrai(λ) = 0.    In this case, only the indices of fault inputs sysr.faults must be specified   and the indices of the rest of inputs must be void.    The solution of a fault estimation problem can be targeted by   choosing Mrfi(λ) = ei, where ei is the i-th row of the appropriate identity matrix,  and checking that the resulting info.M = 1. \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, New computational approach for the design of fault       detection and isolation filters.        In M. Voicu (Ed.), \"Advances in Automatic Control\", vol. 754 of        The Kluwer International Series in Engineering and Computer Science,        Kluwer Academic Publishers, pp. 367-381, 2003.\n\n[3] A. Varga. New computational paradigms in solving fault detection        and isolation problems. Annual Reviews in Control, 37:25–42, 2013. \n\n\n\n\n\n","category":"function"},{"location":"FDIsynthesis.html#FaultDetectionTools.ammsyn","page":"Solving fault detection and isolation problems","title":"FaultDetectionTools.ammsyn","text":"ammsyn(sysf::FDIModel, sysr::FDFilterIF; nullspace = true, simple = false, mindeg = false, \n                       regmin = true, normalize = \"infnorm\", H2syn = false, reltol = 1.e-4, \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate model-matching problem (AMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given stable reference filter sysr::FDFilterIF.  The computed stable and proper filter objects Q and R contain the  fault detection filter, representing a solution of the AMMP, and its internal form, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq,  info.HDesign, info.nonstandard, info.gammaopt0, info.gammaopt and info.gammasub,   contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filter sysr.sys is in a standard or descriptor state-space form sysr.sys = (Ar-λEr,Br,Cr,Dr), which corresponds to the input-output form  \n\n   yr = Mru(λ)*u + Mrd(λ)*d + Mrf(λ)*f + Mrw(λ)*w + Mra(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yr, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mru(λ), Mrd(λ), Mrf(λ), Mrw(λ), and Mra(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrix is considered null. \n\nThe fault detection filter object Q, contains in Q.sys the resulting filter  in a standard state-space form, which generates the residual signal r.  The corresponding input-output (implementation) form is\n\n        r = Qy(λ)*y + Qu(λ)*u\n\nwhere Qy(λ) and Qu(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nLet define \n\n  Ge(λ) = | Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |,  Mr(λ) = | Mru(λ) Mrd(λ) Mrf(λ) Mrw(λ) Mra(λ) | . \n          |  I     0     0     0     0    |\n\nIn the standard case, Ge(λ) has no zeros on the boundary of the  stability domain, and the resulting stable filter Q(λ) := |Qy(λ) Qu(λ)| is  Q(λ) = Q0(λ), where Q0(λ) is the optimal solution of the H∞- or H2-norm error minimization problem\n\ngammaopt0 = ||Q0(λ)*Ge(λ)-M(λ)*Mr(λ)|| = min,         (1)\n\nwhere M(λ) = M0(λ) is an updating factor chosen as follows: M0(λ) = I in the case of emplyoing the  H∞ norm, while in the case of employing the H2 norm, M0(λ) = I for a discrete-time system or, for a continuous-time system,  M0(λ) is determined a stable, diagonal, and invertible transfer function  matrix, which ensures the existence of a finite H2-norm.\n\nIn the non-standard case, Ge(λ)  has zeros on the boundary of the  stability domain, and the resulting optimal filter Q0(λ), which solves  the H∞- or H2-norm error minimization problem (1) is a possibly  unstable or improper. A second updating factor M1(λ) is determined, with    the same properties as M0(λ), which ensures that the computed stable and   proper filter Q(λ) := M1(λ)*Q0(λ) represents a suboptimal solution of an  updated H∞- or H2-norm error minimization problem, for which the    achieved suboptimal model-matching performance is\n\ngammasub = ||Q(λ)*Ge(λ)-M(λ)*Mr(λ)|| ,            (2)\n\nwhere M(λ) := M1(λ)*M0(λ). The optimal solution Qt(λ) of the  updated H∞- or H2-norm error minimization problem \n\ngammaopt = ||Qt(λ)*Ge(λ)-M(λ)*Mr(λ)|| = min ,     (3)\n\nis still possibly unstable or improper. The values of gammaopt0, gammaopt and gammasub are returned in info.gammaopt0, info.gammaopt and info.gammasub, respectively.\n\nThe fault detection filter internal form object R, contains R.sys, the resulting  internal form of the filter  in a standard state-space form, which generates the residual signal r, and corresponds to the  input-output form\n\n   r = Ru(λ)*u + Rd(λ)*d + Rf(λ)*f + Rw(λ)*w + Ra(λ)*aux ,\n\nwhere \n\n   | Ru(λ) Rd(λ) Rf(λ) Rw(λ) Ra(λ) | = Q(λ)*Ge(λ).\n\nThe indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively. The state-space realization of the resulting M(λ) is returned in info.M.\n\nVarious user options can be specified via keyword arguments as follows:\n\nIf H2syn = false (default), a H∞-norm based synthesis is performed, while  if H2syn = true, a H2-norm based synthesis is performed. \n\nreltol = tol specifies the relative tolerance tol for the desired  accuracy of γ-iteration (default:  tol = 1.e-4).\n\nIf mindeg = true, a least order filter synthesis is performed, if possible, while  with minimal = false (default) no least order synthesis is performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case  when sysr.controls and/or sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) of G(λ) = [Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing a left annihilator Nl(λ) as a minimal left nullspace basis of G(λ).  \n\nIf HDesign = H is a full row rank design matrix, then H*Nl(λ) is used as left annihilator instead Nl(λ) (default: HDesign = missing).\n\nIf nullspace = true (default) and sysr.controls and/or sysr.disturbances are void,  a minimal proper nullspace basis is used at the initial reduction step. If nullspace = false and sysr.controls and/or sysr.disturbances are void,  a full-order observer based nullspace basis is used at the  initial reduction step. This option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if both sysr.controls and sysr.disturbances are non-void. \n\nIf simple = true, a simple proper nullspace basis   is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrix M(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation;\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms (default).\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign, gammaopt0, gammaopt, gammasub, nonstandard), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is the employed stable and invertible updating filter used to solve the AMMP,  with a stable, diagonal and invertible transfer function matrix M(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is the design matrix H employed for the synthesis of     the fault detection filter Q; H = missing if no design matrix was involved;\n\ninfo.gammaopt0 is the optimal performance gammaopt0 for the original problem (1); \n\ninfo.gammaopt is the optimal performance gammaopt for the updated problem (3); \n\ninfo.gammasub is the suboptimal performance gammasub in (2); \n\ninfo.nonstandard is set to true for a non-standard problem     (i.e., Ge(λ) has zeros on the boundary of the stability domain), and set to     false for a standard problem        (i.e., Ge(λ) has no zeros on the boundary of the stability domain). \n\nMethod: The synthesis Procedure AMMS from [1] is implemented. The  Procedure AMMS relies on the approximate model-matching synthesis method  proposed in [2]. For more details on computational aspects see [3].  \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, Integrated computational algorithm for solving      H_inf-optimal FDI problems. In Proc. of the IFAC World Congress,      Milano, Italy, pp. 10187–10192, 2011.\n\n[3] A. Varga. Descriptor system techniques in solving H_2/H-Inf-optimal     fault detection and isolation problems\". In L. T. Biegler,       S. L. Campbell, and V. Mehrmann (Eds.), Control and Optimization      with Differential-Algebraic Constraints, vol. 23 of Advances in      Design and Control, pp. 105–125. SIAM, 2012. \n\n\n\n\n\nammsyn(sysf::FDIModel, sysr::FDIFilterIF; nullspace = true, simple = false, mindeg = false, \n                       regmin = true, normalize = \"infnorm\", H2syn = false, reltol = 1.e-4, \n                       sdeg, smarg, poles, freq, HDesign, tcond, offset, \n                       atol, atol1, atol2, atol3, rtol, fast = true) \n                       -> (Q::FDFilter, R::FDFilterIF, info)\n\nSolve the approximate model-matching problem (AMMP) for a given synthesis model sysf::FDIModel with additive faults  and a given bank of stable reference filters sysr::FDIFilterIF. The computed stable and proper filter objects Q and R contain the  bank of fault detection filters, representing the component-wise solution of the AMMP, and  their internal forms, respectively.\n\nThe returned named tuple info, with the components info.tcond, info.degs, info.M, info.freq,  info.HDesign, info.nonstandard, info.gammaopt0, info.gammaopt and info.gammasub,   contains additional synthesis related information (see below). \n\nThe continuous- or discrete-time system sysf.sys is in a standard or descriptor state-space form sysf.sys = (A-λE,B,C,D), which corresponds to the input-output form  \n\n   y = Gu(λ)*u + Gd(λ)*d + Gf(λ)*f + Gw(λ)*w + Ga(λ)*aux,\n\nwith the Laplace- or Z-transformed plant outputs y, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Gu(λ), Gd(λ), Gf(λ), Gw(λ), and Ga(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysf.controls, sysf.disturbances, sysf.faults, sysf.noise and sysf.aux, respectively.\n\nThe continuous- or discrete-time reference filters packed in sysr  are in a standard or descriptor state-space form, where the i-th filter  sysr.sys[i] = (Ari-λEri,Bri,Cri,Dri) corresponds to the input-output form  \n\n   yri = Mrui(λ)*u + Mrdi(λ)*d + Mrfi(λ)*f + Mrwi(λ)*w + Mrai(λ)*aux,\n\nwith the Laplace- or Z-transformed reference filter outputs yri, control inputs u,  disturbance inputs d, fault inputs f, noise inputs w and auxiliary  inputs aux, and with Mrui(λ), Mrdi(λ), Mrfi(λ), Mrwi(λ), and Mrai(λ) the corresponding  transfer-function matrices. The indices of control, disturbance, fault, noise and auxiliary inputs are contained in the associated integer vectors  sysr.controls, sysr.disturbances, sysr.faults, sysr.noise and sysr.aux, respectively. If any of the above vectors is void, then the corresponding transfer function matrices are considered null. \n\nThe fault detection and isolation filter object Q, contains in its i-th  component Q.sys[i] the resulting filter  in a standard state-space form, which generates the i-th component  ri of the residual signal.  The corresponding input-output (implementation) form is\n\n        ri = Qyi(λ)*y + Qui(λ)*u\n\nwhere Qyi(λ) and Qui(λ) are the transfer function matrices from the output and control inputs to the residual.  The indices of output and control inputs are contained in the integer vectors  Q.outputs and Q.controls, respectively.\n\nLet define \n\n  Ge(λ) = | Gu(λ) Gd(λ) Gf(λ) Gw(λ) Ga(λ) |,  Mri(λ) = | Mrui(λ) Mrdi(λ) Mrfi(λ) Mrwi(λ) Mrai(λ) | . \n          |  I     0     0     0     0    |\n\nIn the standard case, Ge(λ) has no zeros on the boundary of the  stability domain, and each resulting component stable filter Qi(λ) := |Qyi(λ) Qui(λ)| is  Qi(λ) = Q0i(λ), where Q0i(λ) is the optimal solution of the H∞- or H2-norm error minimization problem\n\ngammaopt0i = ||Q0i(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| = min,         (1)\n\nwhere Mi(λ) = M0i(λ) is an updating factor chosen as follows: M0i(λ) = I in the case of emplyoing the  H∞ norm, while in the case of employing the H2 norm, M0i(λ) = I for a discrete-time system or, for a continuous-time system,  M0i(λ) is determined a stable, diagonal, and invertible transfer function  matrix, which ensures the existence of a finite H2-norm.\n\nIn the non-standard case, Ge(λ)  has zeros on the boundary of the  stability domain, and each resulting optimal component filter Q0i(λ), which solves  the H∞- or H2-norm error minimization problem (1) is a possibly  unstable or improper. A second updating factor M1i(λ) is determined, with    the same properties as M0i(λ), which ensures that the computed stable and   proper filter Qi(λ) := M1i(λ)*Q0i(λ) represents a suboptimal solution of an  updated H∞- or H2-norm error minimization problem, for which the    achieved suboptimal model-matching performance is\n\ngammasubi = ||Qi(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| ,            (2)\n\nwhere Mi(λ) := M1i(λ)*M0i(λ). The optimal solutions Qti(λ) of the  updated H∞- or H2-norm error minimization problem \n\ngammaopti = ||Qti(λ)*Ge(λ)-Mi(λ)*Mri(λ)|| = min ,     (3)\n\nis still possibly unstable or improper. The values of gammaopt0i, gammaopti and gammasubi are returned in the i-th components of the vectors info.gammaopt0, info.gammaopt and info.gammasub, respectively.\n\nThe fault detection and isolation filter internal form object R,  contains in its i-th component R.sys[i], the resulting  internal form of the filter  in a standard state-space form,  which generates the i-th component ri of residual signal , and corresponds to the  input-output form\n\n   ri = Rui(λ)*u + Rdi(λ)*d + Rfi(λ)*f + Rwi(λ)*w + Rai(λ)*aux ,\n\nwhere \n\n   | Rui(λ) Rdi(λ) Rfi(λ) Rwi(λ) Rai(λ) | = Qi(λ)*Ge(λ).\n\nThe indices of the inputs u, d, f, w and aux of the resulting filter R.sys are  contained in the integer vectors R.controls, R.disturbances, R.faults, R.noise and R.aux, respectively. The state-space realization of the resulting Mi(λ) is returned in the i-th component of the vector info.M. \n\nVarious user options can be specified via keyword arguments as follows:\n\nIf H2syn = false (default), a H∞-norm based synthesis is performed, while  if H2syn = true, a H2-norm based synthesis is performed. \n\nreltol = tol specifies the relative tolerance tol for the desired  accuracy of γ-iteration (default:  tol = 1.e-4).\n\nIf mindeg = true, least order filter syntheses are performed, if possible, while  with minimal = false (default) no least order synthesis are performed.  \n\nIf regmin = true (default), the regularization (see [1]) is performed for the case  when sysr.controls and/or sysr.disturbances are void with the selection of  a least order left annihilator Nl(λ) of G(λ) = [Gu(λ) Gd(λ); I 0 ].  If regmin = false, the regularization is performed by choosing a left annihilator Nl(λ) as a minimal left nullspace basis of G(λ).  \n\nIf HDesign = H is a vector of full row rank design matrices,  then H[i]*Nl(λ) is used as left annihilator instead Nl(λ) for the synthesis of the i-th filter (default: HDesign = missing).\n\nIf nullspace = true (default) and sysr.controls and/or sysr.disturbances are void,  a minimal proper nullspace basis is used at the initial reduction step. If nullspace = false and sysr.controls and/or sysr.disturbances are void,  a full-order observer based nullspace basis is used at the  initial reduction step. This option can  only be used for a proper system without disturbance inputs.  The nullspace option is ignored if both sysr.controls and sysr.disturbances are non-void. \n\nIf simple = true, a simple proper nullspace basis   is emplyed as left annihilator for synthesis.  The orders of the basis vectors are provided in info.deg.  If simple = false (default), then a minimal proper nullspace basis is computed. \n\noffset = β specifies the boundary offset β to assess the stability of poles.  Accordingly, for the stability of a continuous-time system all real parts of poles must be at most -β,  while for the stability of a discrete-time system all moduli of poles must be at most 1-β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nsmarg = α specifies the stability margin which defines the stability  domain Cs of poles, as follows:  for a continuous-time system, Cs is the set of complex numbers  with real parts at most α,  while for a discrete-time system, Cs is the set of complex numbers with  moduli at most α < 1 (i.e., the interior of a disc of radius α centered in the origin).  If smarg is missing, then the employed default values are α = -β  for a continuous-time system and α = 1-β for a discrete-time system,  where β is the boundary offset specified by the keyword argument offset = β. \n\nsdeg = γ is the prescribed stability degree for the poles of the filters Q and R  (default: γ = -0.05 for the real parts of poles for a continuous-time system and γ = 0.95 for the magnitudes of poles for a discrete-time system). \n\npoles = v specifies a complex vector v containing a complex conjugate set   of desired poles within the stability domain Cs to be assigned for the filters Q and R (default: poles = missing).\n\ntcond = tcmax specifies the maximum alowed condition number tcmax  of the employed non-orthogonal transformations (default: tcmax = 1.e4).\n\nfreq = val specifies the value of a test frequency to be employed to  check the full column rank (i.e., left-invertibility) solvability condition  (default: randomly generated in the interval (0,1)).  The employed value of freq is returned in info.freq.\n\nnormalize = job specifies the option for the normalization   of the diagonal elements of the updating matrices Mi(λ) as follows:\n\n  job = \"gain\"    – scale with the gains of the zero-pole-gain representation;\n  job = \"dcgain\"  – scale with the DC-gains;\n  job = \"infnorm\" – scale with the values of infinity-norms (default).\n\nThe rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysf.sys.  The keyword argument atol3 is an absolute tolerance for observability tests (default: internally determined value).  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\nThe resulting named tuple info contains (tcond, degs, M, freq, HDesign, gammaopt0, gammaopt, gammasub, nonstandard), where:\n\ninfo.tcond is the maximum of the condition numbers of the employed     non-orthogonal transformation matrices; a warning is issued if info.tcond >= tcmax;\n\ninfo.degs is an integer vector containing the increasingly ordered degrees of a left minimal    polynomial nullspace basis of G(λ) := [ Gu(λ) Gd(λ); I 0] (also the left Kronecker indices of G(λ)), if the  state-space realization of [Gu(λ) Gd(λ)] is minimal;\n\ninfo.M is a vector of descriptor systems, whose i-th system info.M[i]  contains the employed stable and invertible updating filter used to solve  the i-th AMMP, with a diagonal transfer function matrix Mi(λ); \n\ninfo.freq is the employed frequency used to check left invertibility  (set to missing if no frequency-based left invertibility check was performed)\n\ninfo.HDesign is a vector of design matrices H, where H[i] is the design matrix  employed for the synthesis of the i-th component of the fault detection filter Q;  H[i] is an empty matrix if no design matrix was involved.\n\ninfo.gammaopt0 is a vector whose i-th component is the optimal performance gammaopt0i for the i-th original problem (1); \n\ninfo.gammaopt is a vector whose i-th component is the optimal performance gammaopti for the i-th updated problem (3); \n\ninfo.gammasub is a vector whose i-th component is the suboptimal performance gammasubi in (2); \n\ninfo.nonstandard is set to true for a non-standard problem     (i.e., Ge(λ) has zeros on the boundary of the stability domain), and set to     false for a standard problem        (i.e., Ge(λ) has no zeros on the boundary of the stability domain). \n\nMethod: The synthesis Procedure AMMS from [1] is used  to determine the component filters. The  Procedure AMMS relies on the approximate model-matching synthesis method  proposed in [2]. For more details on computational aspects see [3].  \n\nReferences:\n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques.                Springer Verlag, 2017; sec. 5.6.\n\n[2] A. Varga, Integrated computational algorithm for solving      H_inf-optimal FDI problems. In Proc. of the IFAC World Congress,      Milano, Italy, pp. 10187–10192, 2011.\n\n[3] A. Varga. Descriptor system techniques in solving H_2/H-Inf-optimal     fault detection and isolation problems\". In L. T. Biegler,       S. L. Campbell, and V. Mehrmann (Eds.), Control and Optimization      with Differential-Algebraic Constraints, vol. 23 of Advances in      Design and Control, pp. 105–125. SIAM, 2012. \n\n\n\n\n\n","category":"function"},{"location":"SynthesisParadigms.html#Synthesis-paradigms","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The implemented computational procedures for the synthesis of fault detection filters share several computational paradigms, which are instrumental in developing generally applicable, numerically reliable and computationally efficient synthesis methods. Similar paradigms are also present in the synthesis methods of model detection filters.  In what follows we shortly review these paradigms and discuss their roles in the synthesis procedures.","category":"page"},{"location":"SynthesisParadigms.html#Nullspace-based-synthesis","page":"Synthesis paradigms","title":"Nullspace-based synthesis","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"An important synthesis paradigm is the use of the nullspace method as a first synthesis step to ensure the fulfillment of the decoupling conditions  R_u(lambda) = 0 and R_d(lambda) = 0. This can be done by choosing Q(lambda) of the form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" Q(lambda) = overline Q_1(lambda) Q_1(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where the factor Q_1(lambda) is a left nullspace basis of the rational matrix","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"G(lambda) = left beginarraycc G_u(lambda)  G_d(lambda)  I_m_u  0 endarrayright  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"It follows","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"R_u(lambda)  R_d(lambda) = Q(lambda)G(lambda)= 0  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The residual generator filter can be rewritten in the alternative form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"mathbfr(lambda) = overline Q_1(lambda)Q_1(lambda)left beginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = overline Q_1(lambda) overlinemathbfy(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"overlinemathbfy(lambda) = Q_1(lambda)leftbeginarrayc\nmathbfy(lambda)mathbfu(lambda)endarrayright = overline G_f(lambda)mathbff(lambda) + overline G_w(lambda)mathbfw(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"with","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" overline G_f(lambda)  overline G_w(lambda)  = Q_1(lambda)\nleft beginarraycc G_f(lambda)  G_w(lambda)  0  0 endarrayright ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"With this first preprocessing step, the original problems formulated for a system with control and disturbance inputs can be reformulated for the above reduced system (without control and disturbance inputs),  for which we have to determine the TFM overline Q_1(lambda) of the simpler fault detection filter. For the details of the implemented computational approach see Section 7.4 of [1]. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the computation of nullspace bases, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#Using-filter-updating-techniques","page":"Synthesis paradigms","title":"Using filter updating techniques","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"In all implemented synthesis procedures, the TFM of the resulting filter Q(lambda) can be expressed in a factored form as","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"Q(lambda) = Q_K(lambda) cdots Q_2(lambda)Q_1(lambda)   ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"where Q_1(lambda) is a left nullspace basis of the above defined G(lambda), satisfying Q_1(lambda)G(lambda) = 0, and  Q_1(lambda), Q_2(lambda)Q_1(lambda), ldots, can be interpreted as partial syntheses addressing specific requirements. Since each partial synthesis may represent a valid fault detection filter, this approach can be flexibly used  for employing or combining different synthesis techniques.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The determination of Q(lambda) in the above factored form can be formulated as a K-step synthesis procedure based on successive updating of an initial filter Q(lambda) = Q_1(lambda) and the nonzero terms of its corresponding  internal form","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"R(lambda) =  R_f(lambda)  R_w(lambda) = Q_1(lambda)left beginarraycc G_f(lambda)  G_w(lambda)   0  0 endarrayright","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"as follows: for k = 2 ldots K, determine Q_k(lambda) using the current Q(lambda) and R(lambda) and  then perform the updating as Q(lambda) leftarrow Q_k(lambda)Q(lambda) and  R(lambda) leftarrow Q_k(lambda)R(lambda). These updating operations are efficiently performed using state-space description based formulas. The main benefit of using explicit state-space based updating formulas is the possibility to ensure at each step the cancellation of a maximum number of poles and zeros between the factors. This allows to keep the final order of the filter Q(lambda) as low as possible. See Section 7.3 of [1] for a discussion of additional aspects. ","category":"page"},{"location":"SynthesisParadigms.html#Least-order-synthesis-based-on-admissibility-conditions","page":"Synthesis paradigms","title":"Least order synthesis based on admissibility conditions","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The least order synthesis of fault detection filters means to determine filters Q(lambda) with the least possible orders, to help in reducing the computational burden associated with their real-time implementations. The main tool to achieve least order synthesis is the solution of suitable minimal cover problems (see Section 7.5 of [1]). If X_1(lambda) and X_2(lambda) are rational matrices of the same column dimension,  then the left minimal cover problem is to find X(lambda) and Y(lambda) such that","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"X(lambda) = X_1(lambda) + Y(lambda) X_2(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"and the order of X(lambda)  Y(lambda)  is minimal.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"A typical second step in many synthesis procedures is to choose Q_2(lambda) such that the product Q_2(lambda)Q(lambda) has least dynamical order and, simultaneously, a certain admissibility condition is fulfilled (usually involving the nonzero TFMs R_f(lambda) and R_w(lambda)). For example, for the solution of the AFDP, the rows of Q(lambda) = Q_1(lambda) form a left nullspace basis and the employed admissibility conditions  are","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"Q_2(lambda)R_f_j(lambda) not = 0 j = 1 ldots m_f ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"which  guarantee the detectability of all fault components, and additionally, the full row rank requirement on Q_2(lambda)R_w(lambda). The latter condition is only imposed for convenience, to simplify the subsequent computational steps. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"The determination of candidate solutions Q_2(lambda) such that Q_2(lambda)Q(lambda) has least order  can be done by solving left minimal cover problems, where X_1(lambda) and X_2(lambda) represent disjoint subsets of basis vectors, such that: Q(lambda) = leftbeginsmallmatrix X_1(lambda)  X_2(lambda) endsmallmatrixright, Q_2(lambda) =  I  Y(lambda),  and X(lambda) = Q_2(lambda)Q(lambda) and Y(lambda) represent the solution of the left cover problem. A systematic search over increasing orders of candidate solutions can be performed and the search stops when the admissibility conditions are fulfilled.","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"State-space representation based computational methods for the solution of minimum dynamic cover problems are described in Sections 7.5 and 10.4 of [1], together with explicit updating formulas of the state-space realizations of  Q(lambda) and R(lambda).","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the solution of minimal cover problems, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#Stabilization-via-left-coprime-factorization","page":"Synthesis paradigms","title":"Stabilization via left coprime factorization","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"A desired dynamics of the resulting final filters Q(lambda) and R(lambda) can be enforced by choosing a suitable invertible factor M(lambda), such that  M(lambda) Q(lambda)  R(lambda)  has desired poles. This can be achieved by computing a left coprime factorization","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":" Q(lambda)  R(lambda)  = M^-1(lambda)  N_Q(lambda)  N_R(lambda)  ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"with M(lambda) and  N_Q(lambda)  N_R(lambda)  coprime and having arbitrary stable poles, and then performing the updating operations Q(lambda) leftarrow N_Q(lambda) and  R(lambda) leftarrow N_R(lambda). The stabilization via a left coprime factorization is usually performed as the last step of the synthesis procedures. ","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For a detailed discussion of the coprime factorization based stabilization approach see Sections 7.6 and 10.4 of [1], where coprime factorization methods, based on recursive pole dislocation techniques are described, which produce directly the numerator factors N_Q(lambda) and N_R(lambda) (thus implicitly perform  the updating operations as well).","category":"page"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"For the solution of coprime factorizations, functions available in the DescriptorSystems package are employed. ","category":"page"},{"location":"SynthesisParadigms.html#References","page":"Synthesis paradigms","title":"References","text":"","category":"section"},{"location":"SynthesisParadigms.html","page":"Synthesis paradigms","title":"Synthesis paradigms","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = FaultDetectionTools\nDocTestSetup = quote\n    using FaultDetectionTools\nend","category":"page"},{"location":"index.html#FaultDetectionTools.jl","page":"Home","title":"FaultDetectionTools.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The FaultDetectionTools.jl package (or shortlyFDITools) is a collection of Julia functions for the analysis and solution  of fault detection and isolation (FDI) problems and model detection problems. The functions of this collection rely on  the DescriptorSystems package [2], whose underlying computational functions are based on the MatrixPencils.jl [3] and MatrixEquations.jl [4] packages. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The implemented functions are based on the computational procedures described in Chapters 5, 6 and 7 of the book:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga, \"Solving Fault Diagnosis Problems, Linear Synthesis Techniques\", vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This book describes the mathematical background of solving synthesis problems of fault detection and model detection filters and gives detailed descriptions of the underlying synthesis procedures. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The targeted functionality parallels the functionality of the MATLAB collection of tools FDITOOLS, whose User's Guide of the version V1.0 is provided in the file fditoolsdoc.pdf.   Supplementary information on the targeted functionality is also available on arXiv in the documentation of the companion MATLAB FDITOOLS collection.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The available functions in the current version of the FaultDetectionTools.jl package are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building FDI related objects","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FDIModel  Fault detection and isolation synthesis model.\nFDFilter  Fault detection filter object.\nFDIFilter  Fault detection and isolation filter object.\nFDFilterIF  Fault detection filter internal form object.\nFDIFilterIF  Fault detection and isolation filter internal form object.\nfdimodset  Setup of synthesis models for solving fault detection and isolation problems.\nfdIFeval  Evaluation of the internal forms of fault detection and isolation filters. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Analysis of FDI synthesis models","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdigenspec  Generation of achievable FDI specifications.\nfdichkspec  Feasibility analysis of a set of FDI specifications.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving FDI problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"efdsyn  Exact synthesis of fault detection filters.\nefdisyn  Exact synthesis of fault detection and isolation filters.\nafdsyn  Approximate synthesis of fault detection filters.\nafdisyn  Approximate synthesis of fault detection and isolation filters.\nemmsyn  Exact model-matching based synthesis of fault detection filters.\nammsyn  Approximate model-matching based synthesis of fault detection filters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Performance evaluation of FDI filters","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fditspec  Computation of the weak or strong structure matrix.\nfdisspec  Computation of the strong structure matrix.\nfdiscond  Computation of the fault detection sensitivity condition.\nfdif2ngap  Computation of the fault-to-noise gap.\nfdimmperf  Computation of the model-matching performace.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Building model detection related objects","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"MDModel  Model detection component synthesis model.\nMDMModel  Model detection multiple synthesis model.\nmdmodset  Setup of multiple synthesis models for solving model detection problems.\nMDFilter  Model detection filter object.\nMDFilterIF  Model detection filter internal form object.\nmdIFeval  Evaluation of the internal forms of model detection filters. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Analysis of model reduction synthesis models","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"mddist  Computation of distances between component models.\nmddist2c  Computation of pairwise distances between two sets of component models.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Solving model detection problems","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"emdsyn  Exact synthesis of model detection filters.\namdsyn  Approximate synthesis of model detection filters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Performance evaluation of model detection filters","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"mdspec  Computation of the weak structure matrix.\nmdsspec  Computation of the strong structure matrix.\nmdperf  Computation of the distance-matching performace.\nmdmatch  Computation of the distance-matching performace to a component model.\nmdgap  Computation of the noise gaps.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Computational utilities","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"fdhinfminus  Evaluation of the H∞- index of the transfer function matrix of a descriptor system model.  \nfdhinfmax  Evaluation of the maximum of column norm of the transfer function matrix of a descriptor system model.  \nfditspec_  Computation of the weak or strong structure matrix of a descriptor system model.\nfdisspec_  Computation of the strong structure matrix of a descriptor system model.\nfdiscond_  Computation of the column-gains sensitivity condition of the transfer function matrix of a descriptor system model.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/FaultDetectionTools.jl/blob/master/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2]  A. Varga, DescriptorSystems.jl: Manipulation of generalized state-space (descriptor) system representations. Zenodo: https://doi.org/10.5281/zenodo.5148319.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[4]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"}]
}
