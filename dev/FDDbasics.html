<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fault detection and diagnosis basics · FaultDetectionTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">FaultDetectionTools.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href="FDDbasics.html">Fault detection and diagnosis basics</a><ul class="internal"><li><a class="tocitem" href="#Synthesis-models"><span>Synthesis models</span></a></li><li><a class="tocitem" href="#Residual-generation"><span>Residual generation</span></a></li><li class="toplevel"><a class="tocitem" href="#Structure-matrix"><span>Structure matrix</span></a></li><li class="toplevel"><a class="tocitem" href="#Fault-diagnosis-problems"><span>Fault diagnosis problems</span></a></li></ul></li><li><a class="tocitem" href="MDbasics.html">Model detection basics</a></li><li><a class="tocitem" href="SynthesisParadigms.html">Synthesis paradigms</a></li></ul></li><li><span class="tocitem">Fault Detection</span><ul><li><a class="tocitem" href="FDIObjects.html">Building fault detection and isolation related objects</a></li><li><a class="tocitem" href="FDIanalysis.html">Analysis of FDI synthesis models</a></li><li><a class="tocitem" href="FDIsynthesis.html">Solving fault detection and isolation problems</a></li><li><a class="tocitem" href="FDIperformance.html">Performance evaluation of FDI filters</a></li></ul></li><li><span class="tocitem">Model Detection</span><ul><li><a class="tocitem" href="MDObjects.html">Building model detection related objects</a></li><li><a class="tocitem" href="MDanalysis.html">Analysis of model detection synthesis models</a></li><li><a class="tocitem" href="MDsynthesis.html">Solving model detection problems</a></li><li><a class="tocitem" href="MDperformance.html">Performance evaluation of model detection filters</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="FDIutils.html">FDI related utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="FDDbasics.html">Fault detection and diagnosis basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="FDDbasics.html">Fault detection and diagnosis basics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/FaultDetectionTools.jl/blob/master/docs/src/FDDbasics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Fault-detection-and-diagnosis-basics"><a class="docs-heading-anchor" href="#Fault-detection-and-diagnosis-basics">Fault detection and diagnosis basics</a><a id="Fault-detection-and-diagnosis-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Fault-detection-and-diagnosis-basics" title="Permalink"></a></h1><h2 id="Synthesis-models"><a class="docs-heading-anchor" href="#Synthesis-models">Synthesis models</a><a id="Synthesis-models-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis-models" title="Permalink"></a></h2><p>The plant models underlying all implemented synthesis methods (also called <em>synthesis models</em>) are linear time-invariant system models, where the faults are equated with special (unknown) disturbance inputs.  An important class of models with additive faults arises when defining the fault signals for two main categories of faults, namely, actuator and sensor faults. Two basic forms of synthesis models are used.</p><p>The input-output plant model with additive faults  has the form</p><p class="math-container">\[{\mathbf{y}}(\lambda) = G_u(\lambda){\mathbf{u}}(\lambda) +
G_d(\lambda){\mathbf{d}}(\lambda) + G_f(\lambda){\mathbf{f}}(\lambda) +
G_w(\lambda){\mathbf{w}}(\lambda) ,\]</p><p>where  <span>${\mathbf{y}}(\lambda)$</span>, <span>${\mathbf{u}}(\lambda)$</span>, <span>${\mathbf{d}}(\lambda)$</span>, <span>${\mathbf{f}}(\lambda)$</span>, and <span>${\mathbf{w}}(\lambda)$</span> (with boldface notation), are the Laplace-transformed (in the continuous-time case) or Z-transformed (in the discrete-time case)  <span>$p$</span>-dimensional system output vector <span>$y(t)$</span>, <span>$m_u$</span>-dimensional control input vector <span>$u(t)$</span>, <span>$m_d$</span>-dimensional disturbance vector <span>$d(t)$</span>, <span>$m_f$</span>-dimensional fault vector <span>$f(t)$</span> and <span>$m_w$</span>-dimensional noise vector <span>$w(t)$</span>, respectively, and where <span>$G_u(\lambda)$</span>, <span>$G_d(\lambda)$</span>, <span>$G_f(\lambda)$</span>   and <span>$G_w(\lambda)$</span> are proper <em>transfer function matrices</em> (TFMs) from the respective inputs to outputs.  Input-output models with additive faults of the above form are useful in formulating various fault diagnosis problems, in deriving general solvability conditions and in describing conceptual synthesis procedures. However, these models are generally not suited for numerical computations, due to the  potentially high sensitivity of polynomial-based model representations.</p><p>For computational purposes, instead of the above input-output model with the compound TFM <span>$[\, G_u(\lambda) \; G_d(\lambda) \; G_f(\lambda) \; G_w(\lambda) \,]$</span>, an equivalent state-space model is used having the form</p><p class="math-container">\[\begin{array}{rcl} E\lambda x(t) &amp;=&amp; Ax(t) + B_u u(t) + B_d d(t) + B_f f(t) + B_w w(t) \, ,  \\
y(t) &amp;=&amp;Cx(t) + D_u u(t) + D_d d(t) +  D_f f(t) + D_w w(t)  \, ,
\end{array}\]</p><p>with the <span>$n$</span>-dimensional state vector <span>$x(t)$</span>, where <span>$\lambda x(t) := \dot{x}(t)$</span> or <span>$\lambda x(t) := x(t+1)$</span> depending on the type of the system, continuous- or discrete-time, respectively.  The matrix <span>$E$</span> is generally invertible and is frequently  taken as <span>$E = I_n$</span>. Plant models of the above state-space form often arise from the linearization of nonlinear dynamic plant models in specific operation points and for  fixed values of plant parameters. The noise inputs generally  account  for the effects of uncertainties (e.g., inherent  variabilities in operating points and parameters).</p><p>To indicate the input-output equivalence of the two types of models, we use the notation</p><p class="math-container">\[[\, G_u(\lambda) \; G_d(\lambda) \; G_f(\lambda) \; G_w(\lambda) \,] = \left[ \begin{array}{c|cccc} A-\lambda E &amp; B_u &amp; B_d &amp; B_f &amp; B_w \\  \hline
C &amp; D_u &amp; D_d &amp; D_f &amp; D_w \end{array}\right] ,\]</p><p>which stays for the following relations between the elements of the two representations:</p><p class="math-container">\[\begin{array}{lll} G_u(\lambda) &amp;=&amp; C(\lambda E-A)^{-1}B_u+D_u \\
G_d(\lambda) &amp;=&amp; C(\lambda E-A)^{-1}B_d+D_d \\
G_f(\lambda) &amp;=&amp; C(\lambda E-A)^{-1}B_f + D_f\\
G_w(\lambda) &amp;=&amp; C(\lambda E-A)^{-1}B_w + D_w 
\end{array}\]</p><p>The state-space synthesis model underlies the definition of the <a href="FDIObjects.html#FaultDetectionTools.FDIModel"><code>FDIModel</code></a> object used in the functions for the synthesis of fault diagnosis filters.</p><h2 id="Residual-generation"><a class="docs-heading-anchor" href="#Residual-generation">Residual generation</a><a id="Residual-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Residual-generation" title="Permalink"></a></h2><p>A nonzero fault signal <span>$f \neq 0$</span> signifies a deviation from the normal behaviour of the plant due to an unexpected event (e.g., physical component failure or supply breakdown). Generally, the occurrence of a fault must be detected as early as possible to prevent further degradation of the plant behaviour. <em>Fault detection and diagnosis</em> (FDD) is concerned with one or more of the following aspects: the detection of the occurrence of any fault (<em>fault detection</em>), the localization of detected faults (<em>fault isolation</em>), the reconstruction of the fault signal (<em>fault estimation</em>) and the classification of the detected faults and determination of their characteristics (<em>fault identification</em>). The later aspect is not addressed in this package. </p><p>A FDD system is a device (usually based on a collection of real-time processing algorithms) suitably set-up to fulfill the above tasks.  The main component of any FDD system is the <em>residual generator</em> (or <em>fault detection filter</em>), which produces residual signals grouped in a <span>$q$</span>-dimensional vector <span>$r$</span> by processing the available measurements <span>$y$</span> and the known values of control inputs <span>$u$</span>. The role of the residual signals is to indicate the presence  or absence of faults, and therefore the residual <span>$r$</span> must be equal (or close) to zero in the absence of faults and significantly different from zero after a fault occurs.</p><p>For decision-making when solving fault detection problems, a suitable measure of the residual magnitude is generated in a scalar <em>evaluation signal</em> <span>$\theta$</span>  (e.g., <span>$\theta = \|r\|$</span>), which is then used to set a <em>decision variable</em>, say  <span>$\iota$</span>, as follows: <span>$\iota= 1$</span>, if <span>$\theta &gt; \tau$</span> for a detected fault, and <span>$\iota= 0$</span> if <span>$\theta \leq \tau$</span>,  for the lack of faults, where <span>$\tau$</span> is a given detection threshold.</p><p>For decision-making when solving faul isolation problems, <span>$r(t)$</span> is generally a structured vector with, say <span>$n_b$</span> components <span>$r^{(i)}(t)$</span>, <span>$i = 1, \ldots, n_b$</span>, and  <span>$\theta$</span> and <span>$\iota$</span> are <span>$n_b$</span>-dimensional vectors, with <span>$\theta_i$</span> representing a measure of the magnitude of the <span>$i$</span>-th residual component (e.g., <span>$\theta_i = -\|r^{(i)}\|$</span>). The <span>$i$</span>-th component of the binary signature vector <span>$\iota$</span> is set <span>$\iota_i = 1$</span> or <span>$\iota_i = 0$</span> corresponding to a fired (i.e, <span>$\theta_i &gt; \tau$</span>) or not fired (i.e., <span>$\theta_i \leq \tau$</span>)  component <span>$r^{(i)}(t)$</span>, respectively.</p><p>A linear residual generator employed in a FDD system  has the input-output form</p><p class="math-container">\[{\mathbf{r}}(\lambda) = Q(\lambda)\left[ \begin{array}{c}
{\mathbf{y}}(\lambda)\\{\mathbf{u}}(\lambda)\end{array}\right] = 
Q_y(\lambda){\mathbf{y}}(\lambda) + Q_u(\lambda){\mathbf{u}}(\lambda) ,\]</p><p>where <span>$Q(\lambda) = [Q_y(\lambda) \; Q_u(\lambda)]$</span> is the TFM of the filter. For a physically realizable filter,  <span>$Q(\lambda)$</span> must be <em>stable</em> (i.e., with all its poles having negative real parts for a continuous-time system or magnitudes less than one for a discrete-time system). The <em>order</em> of <span>$Q(\lambda)$</span> is the dimension of the state vector of a minimal state-space realization of <span>$Q(\lambda)$</span>. The dimension <span>$q$</span> of the residual vector <span>$r(t)$</span> depends on the fault diagnosis problem to be solved. The above input-output representation is called the <em>implementation form</em> of the fault detection filter and is the basis of its real-time implementation.</p><p>The residual signal <span>$r(t)$</span> generally depends via the system outputs <span>$y(t)$</span> of all system inputs <span>$u(t)$</span>, <span>$d(t)$</span>, <span>$f(t)$</span> and <span>$w(t)$</span>. The <em>internal form</em> of the filter is obtained by replacing in the above equation <span>${\mathbf{y}}(\lambda)$</span> by its expression in the synthesis model, and is given by</p><p class="math-container">\[{\mathbf{r}}(\lambda) = R(\lambda)\left[ \begin{array}{c}{\mathbf{u}}(\lambda)\\
{\mathbf{d}}(\lambda) \\ {\mathbf{f}}(\lambda) \\ {\mathbf{w}}(\lambda)\end{array}\right] =  
R_u(\lambda){\mathbf{u}}(\lambda) +
R_d(\lambda){\mathbf{d}}(\lambda) + 
R_f(\lambda){\mathbf{f}}(\lambda) + R_w(\lambda){\mathbf{w}}(\lambda)
,\]</p><p>where</p><p class="math-container">\[R(\lambda) = [\, R_u(\lambda) \mid  R_d(\lambda) \mid  R_f(\lambda) \mid  R_w(\lambda)\,] := 
Q(\lambda)  \left[ \begin{array}{c|c|c|c} G_u(\lambda) &amp; G_d(\lambda) &amp; G_f(\lambda)  &amp; G_w(\lambda) \\
         I_{m_u} &amp; 0 &amp; 0 &amp; 0 \end{array}\right] .\]</p><p>For a successfully designed filter <span>$Q(\lambda)$</span>, all TFMs in the corresponding internal form <span>$R(\lambda)$</span> are  stable, and  fulfil  specific fault diagnosis requirements.</p><p>The basic functionality  of a well-designed fault detection filter is to ensure the lack of false alarms, in the case when no faults occurred, and the lack of missed detection of faults, in the case of occurrence of a fault. The first requirement is fulfilled if, in the presence of noise, the signal norm <span>$\|r\|$</span> is  sufficiently small for all possible control, disturbance and noise inputs. The requirement on the lack of missed detections is fulfilled provided <span>$\|r\|$</span> is sufficiently large for any fault of sufficiently large magnitude for all possible control, disturbance and noise inputs.</p><p>The fault detection filter in the implementation form underlies the definition of the <a href="FDIObjects.html#FaultDetectionTools.FDFilter"><code>FDFilter</code></a> object, while the internal form underlies the definition of the <a href="FDIObjects.html#FaultDetectionTools.FDFilterIF"><code>FDFilterIF</code></a> object. These objects are generated by several synthesis functions. </p><p>For the isolation of faults, a bank of residual generator filters is employed which is formed by stacking a bank of <span>$n_b$</span> filters of the form</p><p class="math-container">\[{\mathbf{r}}^{(i)}(\lambda) = Q^{(i)}(\lambda)\left[ \begin{array}{c}
{\mathbf{y}}(\lambda)\\{\mathbf{u}}(\lambda)\end{array}\right] \, ,\]</p><p>where the <span>$i$</span>-th filter <span>$Q^{(i)}(\lambda)$</span> generates the corresponding <span>$i$</span>-th residual component  <span>$r^{(i)}(t)$</span> (scalar or vector). The internal form of the <span>$i$</span>-th filter <span>$Q^{(i)}(\lambda)$</span> is </p><p class="math-container">\[{\mathbf{r}}^{(i)}(\lambda) = R^{(i)}(\lambda)\left[ \begin{array}{c}{\mathbf{u}}(\lambda)\\
{\mathbf{d}}(\lambda) \\ {\mathbf{f}}(\lambda) \\ {\mathbf{w}}(\lambda)\end{array}\right] =  
R^{(i)}_u(\lambda){\mathbf{u}}(\lambda) +
R^{(i)}_d(\lambda){\mathbf{d}}(\lambda) + 
R^{(i)}_f(\lambda){\mathbf{f}}(\lambda) + R^{(i)}_w(\lambda){\mathbf{w}}(\lambda)
,\]</p><p>where</p><p class="math-container">\[R^{(i)}(\lambda) = [\, R^{(i)}_u(\lambda) \mid  R^{(i)}_d(\lambda) \mid  R^{(i)}_f(\lambda) \mid  R^{(i)}_w(\lambda)\,] := 
Q^{(i)}(\lambda)  \left[ \begin{array}{c|c|c|c} G_u(\lambda) &amp; G_d(\lambda) &amp; G_f(\lambda)  &amp; G_w(\lambda) \\
         I_{m_u} &amp; 0 &amp; 0 &amp; 0 \end{array}\right] .\]</p><p>This leads to the following structured residual vector <span>$r(t)$</span> and block-structured filters <span>$Q(\lambda)$</span> and <span>$R(\lambda)$</span></p><p class="math-container">\[r(t) = \left[ \begin{array}{c} r^{(1)}(t)\\ \vdots \\ r^{(n_b)}(t) \end{array}\right] , \;
Q(\lambda) = \left[ \begin{array}{c} Q^{(1)}(\lambda)\\ \vdots \\ Q^{(n_b)}(\lambda) \end{array}\right]  , \; R(\lambda) = \left[ \begin{array}{c} R^{(1)}(\lambda)\\ \vdots \\ R^{(n_b)}(\lambda) \end{array} \right]  \,.\]</p><p>The above bank of fault detection filters is the basis of the definition of the fault detection and isolation object <a href="FDIObjects.html#FaultDetectionTools.FDIFilter"><code>FDIFilter</code></a> and its internal form <a href="FDIObjects.html#FaultDetectionTools.FDIFilterIF"><code>FDIFilterIF</code></a>.</p><h1 id="Structure-matrix"><a class="docs-heading-anchor" href="#Structure-matrix">Structure matrix</a><a id="Structure-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-matrix" title="Permalink"></a></h1><p>Consider <span>$R_f(\lambda)$</span>, the TFM from the fault inputs <span>$f$</span> to residual <span>$r$</span> in the internal form, and assume <span>$R_f(\lambda)$</span> is an <span>$n_b\times m_f$</span> block-structured TFM of the form</p><p class="math-container">\[R_f(\lambda) = \left[ \begin{array}{ccc} R^{(1)}_{f_1}(\lambda)&amp; \cdots &amp;R^{(1)}_{f_{m_f}}(\lambda) \\
\vdots &amp; \ddots &amp; \vdots \\
 R^{(n_b)}_{f_1}(\lambda)&amp; \cdots &amp;R^{(n_b)}_{f_{m_f}}(\lambda) \end{array}\right] \, , \]</p><p>where the <span>$(i,j)$</span>-th block of <span>$R_f(\lambda)$</span> is defined as </p><p class="math-container">\[R^{(i)}_{f_j}(\lambda) := Q^{(i)}(\lambda) \left[ \begin{array}{c} G_{f_j}(\lambda) \\ 0 \end{array}\right] .\]</p><p>Here, <span>$Q^{(i)}(\lambda)$</span> is either the <span>$i$</span>-th row of the filter <span>$Q(\lambda)$</span>, in which case <span>$R^{(i)}_{f_j}(\lambda)$</span> is the <span>$(i,j)$</span>-th element of <span>$R_f(\lambda)$</span>, or the <span>$i$</span>-th block row of <span>$Q(\lambda)$</span> corresponding to the <span>$i$</span>-th filter in a bank of <span>$n_b$</span> filters.  In both cases, <span>$R^{(i)}_{f_j}(\lambda)$</span> describes how the <span>$j$</span>-th fault <span>$f_j$</span> influences the <span>$i$</span>-th (scalar or vector) component of the residual <span>$r$</span>.</p><p>We associate to the block structured <span>$R_f(\lambda)$</span> the <span>$n_b\times m_f$</span> binary <em>structure matrix</em> <span>$S_{R_f}$</span>, whose <span>$(i,j)$</span>-th element is defined as</p><p class="math-container">\[\begin{array}{llrll} S_{R_f}(i,j) &amp;=&amp; 1 &amp; \text{ if } &amp; R^{(i)}_{f_j}(\lambda) \not=0 \; ,\\
S_{R_f}(i,j) &amp;=&amp; 0 &amp; \text{ if } &amp; R^{(i)}_{f_j}(\lambda) =0 \, .
\end{array}\]</p><p>If <span>$S_{R_f}(i,j) = 1$</span> then we say that the <span>$i$</span>-th residual component is sensitive to the <span>$j$</span>-th fault <span>$f_j$</span>, while if <span>$S_{R_f}(i,j) = 0$</span> then the <span>$j$</span>-th fault <span>$f_j$</span>  is decoupled from <span>$i$</span>-th residual component. The <span>$m_f$</span> columns of <span>$S_{R_f}$</span> are called <em>fault signatures</em> and play a crucial role in the decision making  for fault isolation. Since each nonzero column of <span>$S_{R_f}$</span> is associated with the corresponding fault input, fault isolation can be performed by comparing the resulting binary decision vector <span>$\iota$</span> in the FDD system (i.e., the signatures of fired or not fired residual components) with the fault signatures coded in the columns of <span>$S_{R_f}$</span>. The rows of <span>$S_{R_f}$</span> play an important role in solving FDI synthesis problems and are called <em>specifications</em>. </p><p>The above definition of the structure matrix <span>$S_{R_f}$</span> is associated with the zero/nonzero blocks of the TFM <span>$R_f(\lambda)$</span> and is also known as the <em>weak structure matrix</em>.  The <em>strong structure matrix</em> is related to the zero/nonzero blocks of the frequency response of <span>$R_f(\lambda)$</span> evaluated for a set of  relevant complex frequencies <span>$\Omega$</span> characterizing the classes of persistent fault inputs. For example, to a <em>real</em> frequency <span>$\omega$</span> which characterizes sinusoidal faults, the corresponding <em>complex</em> frequency in <span>$\Omega$</span> is <span>$j\omega$</span> for a continuous-time system or <span>$\exp(j\omega T_s)$</span> for a discrete-time system with sampling time <span>$T_s$</span> (thus, the null frequency characterizes constant faults). The strong structure matrix is defined as</p><p class="math-container">\[\begin{array}{llrll} S_{R_f}(i,j) &amp;=&amp; 1 &amp; \text{ if } &amp; R^{(i)}_{f_j}(\lambda_z) \not=0 \;  \text{ for all }  \lambda_z \in \Omega ,\\
S_{R_f}(i,j) &amp;=&amp; 0 &amp; \text{ if } &amp; R^{(i)}_{f_j}(\lambda_z) = 0 \, \text{ for any } \lambda_z \in \Omega .
\end{array} \]</p><p>For the determination of the weak or strong structure matrix  the function <a href="FDIperformance.html#FaultDetectionTools.fditspec"><code>fditspec</code></a> is available. Alternatively, the function <a href="FDIperformance.html#FaultDetectionTools.fdisspec"><code>fdisspec</code></a> can be used to determine the strong structure matrix. </p><p>When solving fault isolation problems, the choice of the desired structure matrix <span>$S_{R_f}$</span> is an important aspect. The function <a href="FDIanalysis.html#FaultDetectionTools.fdigenspec"><code>fdigenspec</code></a> allows to compute the maximally achievable structure matrix for a given synthesis model. The function <a href="FDIanalysis.html#FaultDetectionTools.fdichkspec"><code>fdichkspec</code></a> can be employed to check the feasibility of a set of FDI specifications.</p><h1 id="Fault-diagnosis-problems"><a class="docs-heading-anchor" href="#Fault-diagnosis-problems">Fault diagnosis problems</a><a id="Fault-diagnosis-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Fault-diagnosis-problems" title="Permalink"></a></h1><p>Six basic fault diagnosis problems are formulated in what follows and their solutions are addressed by the implemented synthesis functions. To fulfill the basic requirement for the lack of false alarms in the presence of arbitrary control and disturbance inputs, for all problems we require that by a suitable choice of a stable fault detection filter <span>$Q(\lambda)$</span>, we achieve that  the residual signal <span>$r(t)$</span> is fully decoupled from the control input <span>$u(t)$</span> and disturbance input <span>$d(t)$</span>. Thus, the following <em>decoupling conditions</em> must be generally fulfilled:</p><p class="math-container">\[\begin{array}{ll}
  (i) &amp; R_u(\lambda) = 0 ,\\
  (ii) &amp; R_d(\lambda) = 0 .
\end{array}\]</p><p>Since the effect  of a nonzero  noise input <span>$w(t)$</span> can usually not be fully decoupled from the residual <span>$r(t)$</span>, an additional requirement is that the influence of the noise signal <span>$w(t)$</span> is negligible. Thus, the following <em>noise attenuation condition</em> has to be also fulfilled:</p><p class="math-container">\[\begin{array}{ll}
 (iv) &amp; R_w(\lambda) \approx 0, \;\; \textrm{with} \; R_w(\lambda) \; \textrm{stable.}
\end{array} \]</p><p>The condition <span>$R_w(\lambda) \approx 0$</span> expresses the requirement  that the transfer gain <span>$\|R_w(\lambda)\|$</span> (measured by any suitable norm) can be made arbitrarily small and is intended to avoid missed detections in the presence of noise inputs. </p><p>For particular fault diagnosis problems specific requirements on <span>$R_f(\lambda)$</span> have to be additionally fulfilled.</p><p>We distinguish between exact and approximate solutions of fault diagnosis problems. The <em>exact</em> problems impose no conditions regarding noise inputs, excepting the stability of <span>$R_w(\lambda)$</span> in the case when <span>$w \not\equiv 0$</span>. The <em>approximate</em> problems address the case of nonzero noise inputs by employing special techniques to reduce their effects. For both cases we assume the following general internal form of the filter <span>$Q(\lambda)$</span> </p><p class="math-container">\[r(\lambda) =
R_u(\lambda){\mathbf{u}}(\lambda) +
R_d(\lambda){\mathbf{d}}(\lambda)    + R_f(\lambda){\mathbf{f}}(\lambda) + R_w(\lambda){\mathbf{w}}(\lambda) \]</p><h3 id="Exact-fault-detection-problem-(EFDP)"><a class="docs-heading-anchor" href="#Exact-fault-detection-problem-(EFDP)">Exact fault detection problem (EFDP)</a><a id="Exact-fault-detection-problem-(EFDP)-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-fault-detection-problem-(EFDP)" title="Permalink"></a></h3><p><strong>EFDP:</strong> Determine a stable residual generator <span>$Q(\lambda)$</span> such that</p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp;R_{f_j}(\lambda) \not = 0,\; j = 1, \ldots, m_f \;\; \text{with} \;\; R_f(\lambda) \;\; {\color{magenta} \text{stable}} \\
  (iv) &amp;R_w(\lambda) \;\; {\color{magenta} \text{stable}} 
  \end{array}\]</p><p>Condition <span>$(iii)$</span> expresses the <em>complete fault detectability</em> condition [1].</p><p>The EFDP can be formulated with the stronger requirement that the columns of <span>$R_f(\lambda)$</span> do not vanish for a set of  relevant complex frequencies <span>$\Omega$</span> characterizing the classes of persistent fault inputs:</p><p><strong>EFDP with strong fault detectability:</strong>  For a given set of complex frequencies <span>$\Omega$</span>,  determine a stable	residual generator <span>$Q(\lambda)$</span> such that</p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp;R_{f_j}(\lambda_z) \not = 0, \forall \lambda_z \in \Omega, \; j = 1, \ldots, m_f \;\; \text{with} \;\; R_f(\lambda) \;\; {\color{magenta} \text{stable}} \\
  (iv) &amp;R_w(\lambda) \;\; {\color{magenta} \text{stable}} 
  \end{array}\]</p><p>Condition <span>$(iii)$</span> expresses the <em>complete strong fault detectability</em> condition [1].</p><p>When solving fault detection problems, it is important to assess the sensitivity of the residual signal to individual fault components. The assessment of  <em>complete fault detectability</em> can be done by checking  <span>$\| R_{f}(\lambda) \|_{\infty -}  &gt; 0$</span>, where</p><p class="math-container">\[\| R_{f}(\lambda) \|_{\infty -} := \min_j \|R_{f_j}(\lambda)\|_\infty  \]</p><p>is the <span>$\mathcal{H}_{\infty -}$</span>-index defined in [1], as a measure of the degree of complete fault detectability. If <span>$\| R_{f}(\lambda) \|_{\infty -}  = 0$</span>, then at least one fault component is not detectable in the residual signal <span>$r$</span>. The assessment of the <em>strong complete fault detectability</em> with respect to a set of frequencies contained in a set <span>$\Omega$</span> comes down to check  <span>$R_{f_j}(\lambda_z) \neq 0$</span>, for <span>$\forall \lambda_z \in \Omega$</span> and for <span>$j = 1, \ldots, m_f$</span>. Alternatively, the assessment of strong complete fault detectability can be done by checking  <span>$\| R_{f}(\lambda) \|_{\Omega -}  &gt; 0$</span>, where</p><p class="math-container">\[\| R_{f}(\lambda) \|_{\Omega -} := \min_{j}   \{ \inf_{\lambda_z \in \Omega} \|R_{f_j}(\lambda_z)\|_2 \}\]</p><p>is the (modified) <span>$\mathcal{H}_{\infty -}$</span>-index defined over the frequencies contained in <span>$\Omega$</span> (see [1]). Since nonzero values of <span>$\| R_{f}(\lambda) \|_{\infty -}$</span> or <span>$\| R_{f}(\lambda) \|_{\Omega -}$</span> are not invariant to scaling (e.g., when replacing <span>$Q(\lambda)$</span> by <span>$\alpha Q(\lambda)$</span>), these quantities are less appropriate to quantitatively assess the degrees of complete detectability.</p><p>The function <a href="FDIutils.html#FaultDetectionTools.fdhinfminus"><code>fdhinfminus</code></a> can be employed to evaluate <span>$\|R_{f}(\lambda) \|_{\infty -} $ and $\| R_{f}(\lambda) \|_{\Omega -}$</span>. </p><p>A performance measure associated to a fault detection filter <span>$Q(\lambda)$</span> which solves the EFDP is a scaling independent measure of the complete fault detectability called the <em>fault sensitivity condition</em> and is defined (over all frequencies) as</p><p class="math-container">\[ J_1 =   \| R_{f}(\lambda) \|_{\infty -} / \max_j \|R_{f_j}(\lambda)\|_\infty. \]</p><p>Similarly, scaling independent measure of the strong complete fault detectability  can be defined over the frequencies contained in the set <span>$\Omega$</span> as</p><p class="math-container">\[\widetilde J_1 =   \| R_{f}(\lambda) \|_{\Omega -} / \max_{j}\{ \sup_{\lambda_z \in \Omega} \|R_{f_j}(\lambda_z)\|_2 \}. \]</p><p>We have that <span>$0 &lt; J_1 \leq 1$</span> and <span>$0 &lt; \widetilde J_1 \leq 1$</span> and a value of <span>$J_1$</span> (or of <span>$\widetilde J_1$</span>) near to 1, indicates nearly equal sensitivities of residual to all fault components, and makes easier the choice of suitable thresholds for fault detection. On contrary, a small value of <span>$J_1$</span> (or of <span>$\widetilde J_1$</span>) indicates potential difficulties in detecting some components of the fault vector, due to a very low sensitivity of the residual to these fault components. In such cases, employing fault detection filters with several outputs (<span>$q &gt; 1$</span>) could be advantageous.</p><p>For the synthesis of fault detection filters which solve the EFDP the function <a href="FDIsynthesis.html#FaultDetectionTools.efdsyn"><code>efdsyn</code></a> is available and for the evaluation of the  fault sensitivity condition the function <a href="FDIperformance.html#FaultDetectionTools.fdiscond"><code>fdiscond</code></a> is available. </p><h3 id="Exact-fault-detection-and-isolation-problem-(EFDIP)"><a class="docs-heading-anchor" href="#Exact-fault-detection-and-isolation-problem-(EFDIP)">Exact fault detection and isolation problem (EFDIP)</a><a id="Exact-fault-detection-and-isolation-problem-(EFDIP)-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-fault-detection-and-isolation-problem-(EFDIP)" title="Permalink"></a></h3><p><strong>EFDIP:</strong> Given a structure matrix <span>$S$</span>, determine a stable 	residual generator <span>$Q(\lambda)$</span> such that</p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp; S_{R_{f}} = S \;\; \text{with} \;\; R_f(\lambda) \;\; {\color{magenta} \text{stable}} \\
  (iv) &amp;R_w(\lambda) \;\; {\color{magenta} \text{stable}} 
  \end{array}\]</p><p>The condition (iii) expresses the <span>$S$</span> <em>fault isolability property</em> [1].</p><p>The solution of the EFDIP can be addressed by solving <span>$n_b$</span> suitably formulated EFDPs. The <span>$i$</span>-th EFDP arises by reformulating the <span>$i$</span>-th EFDIP for determining the <span>$i$</span>-th  filter <span>$Q^{(i)}(\lambda)$</span> for a structure matrix which is the <span>$i$</span>-th row of <span>$S$</span>. This can be accomplished by redefining the fault components corresponding to zero entries in the <span>$i$</span>-th row of <span>$S$</span> as additional disturbance inputs to be decoupled in the <span>$i$</span>-th residual component <span>$r^{(i)}(t)$</span>.</p><p>When solving fault detection and isolation problems with a targeted structure matrix <span>$S$</span>, we obtain partitioned filters (see above) and we can define for each individual filter an associated fault sensitivity condition number. Let <span>$f^{(i)}$</span> be formed from the subset of faults corresponding to nonzero entries in the <span>$i$</span>-th row of <span>$S$</span> and let <span>$R_{f^{(i)}}^{(i)}(\lambda)$</span> be formed from the corresponding columns of <span>$R_{f}^{(i)}(\lambda)$</span>.  To characterize the  complete fault detectability of the subset of faults corresponding to nonzero entries in the <span>$i$</span>-th row of <span>$S$</span> we can define the fault sensitivity condition number of the <span>$i$</span>-th filter as</p><p class="math-container">\[J_1^{(i)} =   \big\| R_{f^{(i)}}^{(i)}(\lambda) \big\|_{\infty -} / \max_j \big\|R_{f_j}^{(i)}(\lambda)\big\|_\infty . \]</p><p>Similarly, to characterize the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the <span>$i$</span>-th row of <span>$S$</span>,  we define the fault condition number of the <span>$i$</span>-th filter as</p><p class="math-container">\[\widetilde J_1^{(i)} =   \big\| R_{f^{(i)}}^{(i)}(\lambda) \big\|_{\Omega -} / \max_{j}\{ \sup_{\lambda_z \in \Omega} \big\|R_{f_j}^{(i)}(\lambda_z)\big\|_2 \} . \]</p><p>For the synthesis of fault detection filters which solve the EFDIP the function <a href="FDIsynthesis.html#FaultDetectionTools.efdisyn"><code>efdisyn</code></a> is available and for the evaluation of the  fault sensitivity condition the function <a href="FDIperformance.html#FaultDetectionTools.fdiscond"><code>fdiscond</code></a> is available. </p><h3 id="Approximate-fault-detection-problem-(AFDP)"><a class="docs-heading-anchor" href="#Approximate-fault-detection-problem-(AFDP)">Approximate fault detection problem (AFDP)</a><a id="Approximate-fault-detection-problem-(AFDP)-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-fault-detection-problem-(AFDP)" title="Permalink"></a></h3><p><strong>AFDP:</strong> Determine a stable residual generator <span>$Q(\lambda)$</span> such that</p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp;R_{f_j}(\lambda) \not = 0,\; j = 1, \ldots, m_f \;\; \text{with} \;\; R_f(\lambda) \;\; {\color{magenta} \text{stable}} \\
  (iv) &amp; \|R_w(\lambda) \| \approx 0 \;\; \text{with} \;\; R_w(\lambda) \;\; {\color{magenta} \text{stable}}
  \end{array}\]</p><p>The performance of a fault detection filter <span>$Q(\lambda)$</span> which solves the AFDP can be characterized by the <em>fault-to-noise gap</em> defined as </p><p class="math-container">\[J_2 := \|R_{f}(\lambda) \|_{\infty -} / \|R_w(\lambda)\|_{\infty}\]</p><p>By convention, <span>$J_2 = 0$</span> if <span>$\| R_{f}(\lambda) \|_{\infty -} = 0$</span> and <span>$J_2 = \infty$</span> if <span>$\| R_{f}(\lambda) \|_{\infty -} &gt; 0$</span> and <span>$\| R_{w}(\lambda) \|_{\infty} = 0$</span> (e.g., when solving exact synthesis problems without noise inputs).  A finite frequency variant of the above criterion, which allows to address strong fault detectability aspects for a given set <span>$\Omega$</span> of relevant frequencies is</p><p class="math-container">\[\widetilde J_2 = \| R_{f}(\lambda) \|_{\Omega -} / \| R_{w}(\lambda) \|_{\infty} . \]</p><p>The higher the value of <span>$J_2$</span> (or <span>$\widetilde J_2$</span>), the easier is to choose suitable thresholds to be used for fault detection purposes in the presence of noise. Therefore, the maximization of the above gaps is a valuable goal in improving the fault detection capabilities of the fault diagnosis system in the presence of exogenous noise.</p><p>The value <span>$\eta = J_2$</span> can be used to determine an estimation of the minimum size <span>$\delta_{f,min}$</span> of detectable faults, as <span>$\delta_{f,min} = \delta_w / \eta$</span>, where, for <span>$\delta_w$</span> is an upper bound on the magnitude of the noise input <span>$w(t)$</span> (i.e., <span>$\|w \| \leq \delta_w$</span>).  The resulting value of <span>$\delta_{f,min}$</span> can be used to assess the practical usefulness of any solution, and the maximization of the gap <span>$J_2$</span> is always a meaningful goal for the synthesis of fault detection filters. Note that <span>$J_2 = \infty$</span> for a filter <span>$Q(\lambda)$</span> solving an EFDP with <span>$w \equiv 0$</span>. </p><p>For the synthesis of fault detection filters which solve the AFDP the function <a href="FDIsynthesis.html#FaultDetectionTools.afdsyn"><code>afdsyn</code></a> is available and for the evaluation of the  fault sensitivity condition the function <a href="FDIperformance.html#FaultDetectionTools.fdif2ngap"><code>fdif2ngap</code></a> is available. </p><h3 id="Approximate-fault-detection-and-isolation-problem-(AFDIP)"><a class="docs-heading-anchor" href="#Approximate-fault-detection-and-isolation-problem-(AFDIP)">Approximate fault detection and isolation problem (AFDIP)</a><a id="Approximate-fault-detection-and-isolation-problem-(AFDIP)-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-fault-detection-and-isolation-problem-(AFDIP)" title="Permalink"></a></h3><p>Let <span>$S$</span> be a desired <span>$n_b\times m_f$</span> structure matrix targeted to be achieved by using a structured fault detection filter <span>$Q(\lambda)$</span> with <span>$n_b$</span> row blocks (see also the formulation of the EFDIP) and let <span>$R_f(\lambda)$</span> be the corresponding <span>$n_b\times m_f$</span> block-structured TFM. <span>$R_f(\lambda)$</span> can be additively decomposed as <span>$R_f(\lambda) = \widetilde  R_f(\lambda) + \overline R_f(\lambda)$</span>, where  <span>$\widetilde  R_f(\lambda)$</span> and <span>$\overline R_f(\lambda)$</span> have the same block structure as <span>$R_f(\lambda)$</span> and have their <span>$(i,j)$</span>-th blocks defined as</p><p class="math-container">\[\widetilde  R^{(i)}_{f_j}(\lambda) := S_{ij}R^{(i)}_{f_j}(\lambda), \quad \overline R^{(i)}_{f_j}(\lambda) := (1-S_{ij})R^{(i)}_{f_j}(\lambda) \]</p><p>To address the approximate fault detection and isolation problem, we will target to enforce for the part <span>$\widetilde R_f(\lambda)$</span> of <span>$R_f(\lambda)$</span> the desired structure matrix <span>$S$</span>, while the part <span>$\overline R_f(\lambda)$</span> must (ideally) be negligible.</p><p><strong>AFDIP:</strong> Given a structure matrix <span>$S$</span>, determine a stable residual generator <span>$Q(\lambda)$</span> such that</p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp;  S_{\widetilde R_f} = S, \; \overline R_f(\lambda) \approx 0\;\; \text{with} \;\; R_f(\lambda) \;\; {\color{magenta} \text{stable}}
  \\
  (iv) &amp; \|R_w(\lambda) \| \approx 0 \;\; \text{with} \;\; R_w(\lambda) \;\; {\color{magenta} \text{stable}}
  \end{array}\]</p><p>When solving an AFDIP, it is usually attempted to fulfil the stronger requirement that <span>$\overline R_f(\lambda) =  0$</span> (which is equivalent to require <span>$S_{R_f} = S$</span>). If this is not feasible, then the above problem is solved.</p><p>For a partitioned filter corresponding to a targeted structure matrix <span>$S$</span>, we can define for the <span>$i$</span>-th filter component the associated value of the fault-to-noise gap, which  characterizes the noise attenuation properties of the <span>$i$</span>-th filter. Let <span>$f^{(i)}$</span> be formed from the subset of faults corresponding to nonzero entries in the <span>$i$</span>-th row of <span>$S$</span> and  let <span>$\bar f^{(i)}$</span> be formed from the complementary subset of faults corresponding to zero entries in the <span>$i$</span>-th row of <span>$S$</span>. If <span>$R_{f^{(i)}}^{(i)}(\lambda)$</span> and <span>$R_{\bar f^{(i)}}^{(i)}(\lambda)$</span>  are formed from the columns of <span>$R_{f}^{(i)}(\lambda)$</span> corresponding to <span>$f^{(i)}$</span> and <span>$\bar f^{(i)}$</span>, respectively, then the fault-to-noise gap of the <span>$i$</span>-th filter can be defined as</p><p class="math-container">\[ J_{2}^{(i)} =   \big\| R_{f^{(i)}}^{(i)}(\lambda) \big\|_{\infty -} / \big\|\big[\, R_{\bar f^{(i)}}^{(i)}(\lambda) \;  R_{w}^{(i)}(\lambda)\,\big]\big\|_\infty . \]</p><p>For a similar characterization of the strong complete fault detectability of the subset of faults corresponding to nonzero entries in the <span>$i$</span>-th row of <span>$S$</span>,  we have</p><p class="math-container">\[ \widetilde J_{2}^{(i)} =   \big\| R_{f^{(i)}}^{(i)}(\lambda) \big\|_{\Omega -} / \big\|\big[\, R_{\bar f^{(i)}}^{(i)}(\lambda) \;  R_{w}^{(i)}(\lambda)\,\big]\big\|_\infty . \]</p><p>For the synthesis of fault detection and isolation filters which solve the AFDIP the function <a href="FDIsynthesis.html#FaultDetectionTools.afdisyn"><code>afdisyn</code></a> is available and for the evaluation of the  fault sensitivity condition the function <a href="FDIperformance.html#FaultDetectionTools.fdif2ngap"><code>fdif2ngap</code></a> is available. </p><h3 id="Exact-model-matching-problem-(EMMP)"><a class="docs-heading-anchor" href="#Exact-model-matching-problem-(EMMP)">Exact model-matching problem (EMMP)</a><a id="Exact-model-matching-problem-(EMMP)-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-model-matching-problem-(EMMP)" title="Permalink"></a></h3><p>Let <span>$M_r(\lambda)$</span> be a given <span>$q\times m_f$</span> TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as</p><p class="math-container">\[{\mathbf{r}}(\lambda) = M_r(\lambda) {\mathbf{f}}(\lambda). \]</p><p>Together with the decoupling conditions <span>$R_u(\lambda) = 0$</span> and <span>$R_d(\lambda) = 0$</span>, the determination of  <span>$Q(\lambda)$</span> involves the solution of a linear matrix equation with rational function coefficients. However, a particular choice of <span>$M_r(\lambda)$</span> may lead to a solution <span>$Q(\lambda)$</span> which is not proper or is unstable or has both these undesirable properties. Therefore, besides determining <span>$Q(\lambda)$</span>,  the determination of a suitable updating factor <span>$M(\lambda)$</span> of <span>$M_r(\lambda)$</span> is necessary to ensure the stability of the solution <span>$Q(\lambda)$</span> for <span>$R_f(\lambda) = M(\lambda) M_r(\lambda)$</span> (and also of <span>$R_w(\lambda)$</span>). This leads to the following formulation of the EMMP:</p><p><strong>EMMP:</strong> Determine a stable residual generator <span>$Q(\lambda)$</span> and a  stable, diagonal, and invertible <span>$M(\lambda)$</span> such that </p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp; R_f(\lambda) = M(\lambda)M_r(\lambda) \\
  (iv) &amp;R_w(\lambda) \;\; {\color{magenta} \text{stable}} 
  \end{array}\]</p><p>A typical choice for <span>$M_r(\lambda)$</span> is an <span>$m_f \times m_f$</span>  diagonal and invertible TFM, which ensures that each residual <span>$r_i(t)$</span> is influenced only by the fault <span>$f_i(t)$</span>. This would allow the isolation of arbitrary combinations of up to <span>$m_f$</span> simultaneous faults.  The choice <span>$M_r(\lambda) = I_{m_f}$</span> targets the solution of an  <em>exact fault estimation problem</em> (EFEP).</p><p>For the synthesis of fault detection and isolation filters which solve the EMMP the function <a href="FDIsynthesis.html#FaultDetectionTools.emmsyn"><code>emmsyn</code></a> is available. This function can also address the solution of the EMMP with more general reference models (e.g., having components from the control inputs and/or disturbance inputs). </p><h3 id="Approximate-model-matching-problem-(AMMP}"><a class="docs-heading-anchor" href="#Approximate-model-matching-problem-(AMMP}">Approximate model-matching problem (AMMP}</a><a id="Approximate-model-matching-problem-(AMMP}-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-model-matching-problem-(AMMP}" title="Permalink"></a></h3><p>Let <span>$M_r(\lambda)$</span> be a given <span>$q\times m_f$</span> TFM of a stable reference model  specifying the desired input-output behavior from the faults to residuals as</p><p class="math-container">\[{\mathbf{r}}(\lambda) = M_r(\lambda) {\mathbf{f}}(\lambda). \]</p><p><strong>AMMP:</strong> Determine a stable residual generator <span>$Q(\lambda)$</span> and a  stable, diagonal, and invertible <span>$M(\lambda)$</span> such that </p><p class="math-container">\[\begin{array}{rl} (i) &amp; R_u(\lambda) = 0 \\ (ii) &amp; R_d(\lambda) = 0 \\
  (iii) &amp; R_f(\lambda) \approx M(\lambda)M_r(\lambda) \\
  (iv) &amp; \|R_w(\lambda) \| \approx 0 \;\; \text{with} \;\; R_w(\lambda) \;\; {\color{magenta} \text{stable}}
  \end{array}\]</p><p>A criterion suitable to characterize the solution of approximate model-matching based syntheses is the  residual error norm</p><p class="math-container">\[J_3 = \big\| R(\lambda)- M_r(\lambda)\big\|_{\infty/2}, \]</p><p>where <span>$R(\lambda) = R_f(\lambda)$</span> and <span>$M_r(\lambda)$</span> the reference model (possibly updated). For more generality, this criterion can be defined with  <span>$R(\lambda) = [\, R_u(\lambda)\; R_d(\lambda)\; R_f(\lambda)\; R_w(\lambda) \,\,]$</span>, the resulting internal form, and <span>$M_r(\lambda)$</span> the desired reference model <span>$M_r(\lambda) = [\, M_{ru}(\lambda)\; M_{rd}(\lambda)\; M_{rf}(\lambda)\; M_{rw}(\lambda)\,]$</span>. When applied to the results computed by other synthesis approaches (e.g., to solve the AFDP or AFDIP), this criterion can be formulated as</p><p class="math-container">\[\widetilde J_3 = \big\| R_w(\lambda)\big\|_{\infty/2}, \]</p><p>which corresponds to assume that <span>$M(\lambda) = I$</span> and <span>$M_r(\lambda) = [\, R_u(\lambda)\; R_d(\lambda)\; R_f(\lambda)\; 0 \,]$</span> (i.e., a perfect matching of control, disturbance and fault channels is always achieved).</p><p>For the synthesis of fault detection and isolation filters which solve the AMMP the function <a href="FDIsynthesis.html#FaultDetectionTools.ammsyn"><code>ammsyn</code></a> is available. This function can also address the solution of the AMMP with more general reference models (e.g., having components from the control inputs, disturbance inputs and noise inputs). For the evaluation of the  model-matching performace the function <a href="FDIperformance.html#FaultDetectionTools.fdimmperf"><code>fdimmperf</code></a> is available. </p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="MDbasics.html">Model detection basics »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 28 May 2023 10:28">Sunday 28 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
