<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model detection basics · FaultDetectionTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">FaultDetectionTools.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="FDDbasics.html">Fault detection and diagnosis basics</a></li><li class="is-active"><a class="tocitem" href="MDbasics.html">Model detection basics</a><ul class="internal"><li><a class="tocitem" href="#Synthesis-models"><span>Synthesis models</span></a></li><li><a class="tocitem" href="#Residual-generation"><span>Residual generation</span></a></li><li class="toplevel"><a class="tocitem" href="#Structure-matrix"><span>Structure matrix</span></a></li><li class="toplevel"><a class="tocitem" href="#Model-detection-problems"><span>Model detection problems</span></a></li><li><a class="tocitem" href="#Analysis-and-performance-evaluation"><span>Analysis and performance evaluation</span></a></li></ul></li><li><a class="tocitem" href="SynthesisParadigms.html">Synthesis paradigms</a></li></ul></li><li><span class="tocitem">Fault Detection</span><ul><li><a class="tocitem" href="FDIObjects.html">Building fault detection and isolation related objects</a></li><li><a class="tocitem" href="FDIanalysis.html">Analysis of FDI synthesis models</a></li><li><a class="tocitem" href="FDIsynthesis.html">Solving fault detection and isolation problems</a></li><li><a class="tocitem" href="FDIperformance.html">Performance evaluation of FDI filters</a></li></ul></li><li><span class="tocitem">Model Detection</span><ul><li><a class="tocitem" href="MDObjects.html">Building model detection related objects</a></li><li><a class="tocitem" href="MDanalysis.html">Analysis of model detection synthesis models</a></li><li><a class="tocitem" href="MDsynthesis.html">Solving model detection problems</a></li><li><a class="tocitem" href="MDperformance.html">Performance evaluation of model detection filters</a></li></ul></li><li><span class="tocitem">Residual Evaluation</span><ul><li><a class="tocitem" href="FDDsystems.html">Building fault detection and diagnosis systems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="FDIutils.html">FDI related utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="MDbasics.html">Model detection basics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="MDbasics.html">Model detection basics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/FaultDetectionTools.jl/blob/master/docs/src/MDbasics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-detection-basics"><a class="docs-heading-anchor" href="#Model-detection-basics">Model detection basics</a><a id="Model-detection-basics-1"></a><a class="docs-heading-anchor-permalink" href="#Model-detection-basics" title="Permalink"></a></h1><h2 id="Synthesis-models"><a class="docs-heading-anchor" href="#Synthesis-models">Synthesis models</a><a id="Synthesis-models-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis-models" title="Permalink"></a></h2><p>The underlying synthesis techniques of model detection systems rely on multiple-model descriptions of physical fault cases.  The  multiple-model description represents a very general way to describe plant models with various faults. For example, <em>extreme</em> variations of parameters representing the so-called <em>parametric faults</em>, can be easily described by multiple models. Since different degrees of performance degradations of a plant behaviour can be also described via multiple models,   model detection techniques have potentially the capability to address certain fault identification aspects too. Two basic forms of synthesis models are described in what follows.</p><p>For physically modelled faults, each fault mode leads to a distinct component model. Assume that we have <span>$N$</span> <em>stable</em> LTI component models describing the fault-free and faulty systems,  and for <span>$j = 1, \ldots , N$</span> the <span>$j$</span>-th model  is specified in the input-output form</p><p class="math-container">\[{\mathbf{y}}^{(j)}(\lambda) =
G_u^{(j)}(\lambda){\mathbf{u}}(\lambda)
+ G_d^{(j)}(\lambda){\mathbf{d}}^{(j)}(\lambda)
+ G_w^{(j)}(\lambda){\mathbf{w}}^{(j)}(\lambda) ,\]</p><p>where  <span>${\mathbf{y}}^{(j)}(\lambda)$</span>, <span>${\mathbf{u}}(\lambda)$</span>, <span>${\mathbf{d}}^{(j)}(\lambda)$</span> and <span>${\mathbf{w}}^{(j)}(\lambda)$</span> (with boldface notation), are the Laplace-transformed (in the continuous-time case) or Z-transformed (in the discrete-time case) time-dependent vectors, respectively, the measured system output <span>$y^{(j)}(t) \in R^{p}$</span>, control input <span>$u(t) \in R^{m_u}$</span>, disturbance input <span>$d^{(j)}(t) \in R^{m_d^{(j)}}$</span> and noise input <span>$w^{(j)}(t) \in R^{m_w^{(j)}}$</span>, and where <span>$G_u^{(j)}(\lambda)$</span>, <span>$G_d^{(j)}(\lambda)$</span> and <span>$G_w^{(j)}(\lambda)$</span>  are proper and stable TFMs from the corresponding plant inputs to outputs. In general, the disturbance and noise vectors can have different dimensions for different component systems. </p><p><em>Important notice:</em> The requirement of stability of the component models is not necessary for the mathematical solution of the model detection problems formulated below. Nevertheless, this requirement  is essential for the practical applicability of model detection techniques, because the detection of    unstable component models is unrealistic in presence of inherent modelling related uncertainties. </p><p>Input-output models of the above form are useful in formulating various model detection problems, in deriving general solvability conditions and in describing conceptual synthesis procedures. However, these models are generally not suited for numerical computations, due to the  potentially high sensitivity of polynomial-based model representations.</p><p>For computational purposes, instead of the above input-output model with the <span>$j$</span>-th compound TFM <span>$[\, G_u^{(j)}(\lambda) \; G_d^{(j)}(\lambda) \; G_w^{(j)}(\lambda) \,]$</span>, equivalent state-space models are used with the <span>$j$</span>-th model having the form</p><p class="math-container">\[\begin{array}{rcl}E^{(j)}\lambda x^{(j)}(t) &amp;=&amp; A^{(j)}x^{(j)}(t) + B^{(j)}_u u(t) + B^{(j)}_d d^{(j)}(t) + B^{(j)}_w w^{(j)}(t)  \, ,\\
y^{(j)}(t) &amp;=&amp; C^{(j)}x^{(j)}(t) + D^{(j)}_u u(t) + D^{(j)}_d d^{(j)}(t) + D^{(j)}_w w^{(j)}(t)  \, , \end{array} \]</p><p>where <span>$x^{(j)}(t) \in R^{n^{(j)}}$</span> is the state vector of the <span>$j$</span>-th system and,  generally, can have different dimensions for different component systems, and   where <span>$\lambda x^{(j)}(t) := \dot{x}^{(j)}(t)$</span> or <span>$\lambda x^{(j)}(t) := x^{(j)}(t+1)$</span> depending on the type of the system, continuous- or discrete-time, respectively.  Each matrix <span>$E^{(j)}$</span> is generally invertible and is frequently  taken as <span>$E^{(j)} = I_{n^{(j)}}$</span>.  The following relations hold between the elements of the two representations:</p><p class="math-container">\[\begin{array}{lll} G_u^{(j)}(\lambda) &amp;=&amp; C^{(j)}(\lambda E^{(j)}-A^{(j)})^{-1}B_u^{(j)}+D_u^{(j)} \\
G_d^{(j)}(\lambda) &amp;=&amp; C^{(j)}(\lambda E^{(j)}-A^{(j)})^{-1}B_d^{(j)}+D_d^{(j)} \\
G_w^{(j)}(\lambda) &amp;=&amp; C^{(j)}(\lambda E^{(j)}-A^{(j)})^{-1}B_w^{(j)} + D_w^{(j)} 
\end{array}\]</p><p>The state-space synthesis models underly the definition of the <a href="MDObjects.html#FaultDetectionTools.MDModel"><code>MDModel</code></a> and  <a href="MDObjects.html#FaultDetectionTools.MDMModel"><code>MDMModel</code></a>synthesis model objects used in the functions for the synthesis of model detection filters.</p><h2 id="Residual-generation"><a class="docs-heading-anchor" href="#Residual-generation">Residual generation</a><a id="Residual-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Residual-generation" title="Permalink"></a></h2><p>A typical model detection system contains a bank of <span>$N$</span> residual generation filters (or residual generators) </p><p class="math-container">\[{\mathbf{r}}^{(i)}(\lambda) = Q^{(i)}(\lambda)\left[ \begin{array}{c}
{\mathbf{y}}(\lambda)\\{\mathbf{u}}(\lambda)\end{array}\right] , \; i = 1, \ldots, N,\]</p><p>where the <span>$i$</span>-th filter <span>$Q^{(i)}(\lambda)$</span> generates the corresponding <span>$i$</span>-th residual component  <span>$r^{(i)}(t)$</span> (scalar or vector). The dimension <span>$q_i$</span> of the residual vector component <span>$r^{(i)}(t)$</span> can be chosen always one, but occasionally values <span>$q_i &gt; 1$</span> may provide better sensitivity to model mismatches.</p><p><img src="varga_Fig4.1_MDSystem.jpg" alt="Model detection system"/></p><p>For decision making, an <span>$N$</span>-dimensional  evaluation vector <span>$\theta$</span> is employed, whose <span>$i$</span>-th component <span>$\theta_i$</span> usually represents an approximation of  <span>$\|r^{(i)}\|_2$</span>, the <span>$\mathcal{L}_2$</span>- or <span>$\ell_2$</span>-norm of <span>$r^{(i)}$</span>. Then, an <span>$N$</span>-dimensional decision vector <span>$\iota$</span>  is built, whose <span>$i$</span>-th component is set to 0 if <span>$\theta_i \leq \tau_i$</span> and 1 otherwise, where <span>$\tau_i$</span> is a suitable threshold. The <span>$j$</span>-th model is <em>detected</em> if <span>$\iota_j =0$</span> and <span>$\iota_i =1$</span> for all <span>$i \not = j$</span>. It follows that model detection can be interpreted as a particular type of week fault isolation with <span>$N$</span> signature vectors, where the <span>$N$</span>-dimensional <span>$j$</span>-th signature vector has all elements set to one, excepting the <span>$j$</span>-th entry which is set to zero. An alternative decision scheme relevant for addressing multiple-model based adaptive control prooblems can also be devised if <span>$\theta_i$</span> is associated with a distance function from the current model to the <span>$i$</span>-th model. In this case, if <span>$j$</span> is the index of least component of <span>$\theta$</span>, then setting <span>$\iota_j =0$</span> and <span>$\iota_i =1$</span> for all <span>$i \not = j$</span>, the above decision scheme selects that model <span>$j$</span> which best fits with the current model characterized by the measured input and output data. Moreover, to reduce the real-time computational burden, it is occasionally possible to use a number of filters <span>$M$</span>, with <span>$M \ll N$</span>.  For example, a single filter (i.e., <span>$M = 1$</span>) can be sufficient to perform model detection provided the ranges of values of <span>$\theta_1$</span> for a selected class of persistent test signals correctly reflect the distances from the current model to the first component model.   </p><p>Assuming <span>$y(t) = y^{(j)}(t)$</span>, the residual signal component <span>$r^{(i)}(t)$</span> generally depends on all system inputs <span>$u(t)$</span>, <span>$d^{(j)}(t)$</span> and <span>$w^{(j)}(t)$</span> via the system output <span>$y^{(j)}(t)$</span>.  The <em>internal form</em> of the <span>$i$</span>-th filter driven by the <span>$j$</span>-th model is obtained by replacing <span>${\mathbf{y}}(\lambda)$</span> with <span>${\mathbf{y}}^{(j)}(\lambda)$</span>. To make explicit the dependence of <span>$r^{(i)}$</span> on the <span>$j$</span>-th model, we will use <span>$\widetilde r^{(i,j)}$</span>, to denote the <span>$i$</span>-th residual output for the <span>$j$</span>-th model. After replacing <span>${\mathbf{y}}(\lambda)$</span> with <span>${\mathbf{y}}^{(j)}(\lambda)$</span>,  we obtain</p><p class="math-container">\[\begin{array}{lrl}
{\widetilde{\mathbf{r}}}^{(i,j)}(\lambda) &amp;:=&amp; R^{(i,j)}(\lambda) \left[ \begin{array}{c}{\mathbf{u}}(\lambda) \\ {\mathbf{d}}^{(j)}(\lambda)\\ {\mathbf{w}}^{(j)}(\lambda)\end{array}\right]\\ \\[-2mm] &amp;=&amp;
R_u^{(i,j)}(\lambda){\mathbf{u}}(\lambda) +
R_d^{(i,j)}(\lambda){\mathbf{d}}^{(j)}(\lambda) +
R_w^{(i,j)}(\lambda){\mathbf{w}}^{(j)}(\lambda) \, ,
\end{array} \]</p><p>with <span>$R^{(i,j)}(\lambda) := \big[ R_u^{(i,j)}(\lambda) \mid R_d^{(i,j)}(\lambda) \mid R_w^{(i,j)}(\lambda)\big]$</span> defined as</p><p class="math-container">\[R^{(i,j)}(\lambda) :=
Q^{(i)}(\lambda)\left[ \begin{array}{c|c|c} G_u^{(j)}(\lambda) &amp; G_d^{(j)}(\lambda) &amp; G_w^{(j)}(\lambda) \\
I_{m_u} &amp; 0 &amp; 0 \end{array}\right] \, .\]</p><p>This leads to the following structured residual vector <span>$r(t)$</span> and block-structured filter <span>$Q(\lambda)$</span> </p><p class="math-container">\[r(t) = \left[ \begin{array}{c} r^{(1)}(t)\\ \vdots \\ r^{(N)}(t) \end{array}\right] , \;
Q(\lambda) = \left[ \begin{array}{c} Q^{(1)}(\lambda)\\ \vdots \\ Q^{(N)}(\lambda) \end{array}\right]  \,.\]</p><p>For a successfully designed set of stable and proper filters <span>$Q^{(i)}(\lambda)$</span>, <span>$i = 1, \ldots, N$</span>, the corresponding internal representations <span>$R^{(i,j)}(\lambda)$</span> are also a proper and stable.</p><p>The above bank of fault detection filters is the basis of the definition of the model detection filter object <a href="MDObjects.html#FaultDetectionTools.MDFilter"><code>MDFilter</code></a> and its internal form <a href="MDObjects.html#FaultDetectionTools.MDFilterIF"><code>MDFilterIF</code></a>.</p><h1 id="Structure-matrix"><a class="docs-heading-anchor" href="#Structure-matrix">Structure matrix</a><a id="Structure-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Structure-matrix" title="Permalink"></a></h1><p>We can associate to the <span>$N\times N$</span> set of TFMs <span>$R^{(i,j)}(\lambda)$</span> the <span>$N\times N$</span> binary <em>structure matrix</em> <span>$S_{R}$</span>, whose <span>$(i,j)$</span>-th element is defined as</p><p class="math-container">\[\begin{array}{llrll} S_{R}(i,j) &amp;=&amp; 1 &amp; \text{ if } &amp; R_u^{(i,j)}(\lambda) \not=0 \; ,\\
S_{R}(i,j) &amp;=&amp; 0 &amp; \text{ if } &amp; R_u^{(i,j)}(\lambda) =0 \, .
\end{array}\]</p><p>If <span>$S_{R}(i,j) = 1$</span> then we say that the <span>$i$</span>-th residual component is sensitive to the control inputs of the <span>$j$</span>-th model, while if <span>$S_{R}(i,j) = 0$</span> then the control inputs of the <span>$j$</span>-th model are decoupled from <span>$i$</span>-th residual component. The <span>$N$</span> columns of <span>$S_{R}$</span> are called <em>model signatures</em> and play the same role in the decision making as the structure matrices employed for fault isolation. Since each column of <span>$S_{R}$</span> is associated with the corresponding model, model detection can be performed by comparing the resulting binary decision vector <span>$\iota$</span> in the model detection system (i.e., the signatures of fired or not fired residual components) with the signatures coded in the columns of <span>$S_{R}$</span>. All targeted  model detection signatures have the <em>standard</em> shape below, as for example, for <span>$N = 4$</span> </p><p class="math-container">\[S = \left[ \begin{array}{cccc} 0 &amp; 1 &amp; 1 &amp; 1\\ 1 &amp; 0 &amp; 1 &amp; 1\\1 &amp; 1 &amp; 0 &amp; 1\\ 1 &amp; 1 &amp; 1 &amp; 0 
\end{array} \right] .\]</p><p>The above definition of the structure matrix <span>$S_{R}$</span> can be extended to include the effects of disturbance inputs, by using  <span>$\big[ R_u^{(i,j)}(\lambda) \; R_d^{(i,j)}(\lambda) \big]$</span> instead  <span>$R_u^{(i,j)}(\lambda)$</span>. This possibility is relevant especially for the cases when there are no control inputs to be actively manipulated. </p><p>The above defined binary matrix is also known as the <em>weak structure matrix</em> associated to the zero/nonozero components of <span>$R^{(i,j)}(\lambda)$</span>. We can also define the <em>strong structure matrix</em>, which is related to the zero/nonzero blocks of the frequency response of <span>$R^{(i,j)}(\lambda)$</span> evaluated for a set of  relevant complex frequencies <span>$\Omega$</span> characterizing the classes of persistent input signals. For example, to a <em>real</em> frequency <span>$\omega$</span> which characterizes sinusoidal inputs, the corresponding <em>complex</em> frequency in <span>$\Omega$</span> is <span>$j\omega$</span> for a continuous-time system or <span>$\exp(j\omega T_s)$</span> for a discrete-time system with sampling time <span>$T_s$</span> (thus, the null frequency characterizes constant faults). The strong structure matrix is defined as</p><p class="math-container">\[\begin{array}{llrll} S_{R}(i,j) &amp;=&amp; 1 &amp; \text{ if } &amp; R_u^{(i,j)}(\lambda_z) \not=0 \;  \text{ for all }  \lambda_z \in \Omega ,\\
S_{R}(i,j) &amp;=&amp; 0 &amp; \text{ if } &amp; R_u^{(i,j)}(\lambda_z) = 0 \, \text{ for any } \lambda_z \in \Omega .
\end{array} \]</p><p>For the determination of the weak and strong structure matrices the functions  <a href="MDperformance.html#FaultDetectionTools.mdspec"><code>mdspec</code></a> and  <a href="MDperformance.html#FaultDetectionTools.mdsspec"><code>mdsspec</code></a> are available.  </p><h1 id="Model-detection-problems"><a class="docs-heading-anchor" href="#Model-detection-problems">Model detection problems</a><a id="Model-detection-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Model-detection-problems" title="Permalink"></a></h1><p>In this section we formulate the exact and approximate synthesis problems of model detection filters for a collection of <span>$N$</span> <em>stable</em> LTI systems. As in the case of the EFDIP or AFDIP, we seek <span>$N$</span> linear residual generators  (or model  detection filters), which process the measurable system outputs <span>$y(t)$</span> and known control inputs <span>$u(t)$</span> and generate the <span>$N$</span> residual signals <span>$r^{(i)}(t)$</span>  for <span>$i = 1, \ldots, N$</span>. These signals serve for decision-making by comparing the pattern of fired and not fired residuals  with the signatures coded in the columns of the associated standard <span>$N\times N$</span> structure matrix <span>$S$</span> with zeros on the diagonal and ones elsewhere. The standard requirements for the TFMs of the filters <span>$Q^{(i)}(\lambda)$</span>  are <em>properness</em>  and <em>stability</em>. For practical purposes, the orders of the filter <span>$Q^{(i)}(\lambda)$</span> must be as small as possible. Least order filters <span>$Q^{(i)}(\lambda)$</span> can be usually achieved by employing scalar output filters.</p><p>In analogy to the formulations of the EFDIP and AFDIP, we use the internal form of the <span>$i$</span>-th residual generator to formulate the basic model detection requirements. Independently of the presence of the noise inputs <span>$w^{(j)}$</span>, we will target that the <span>$i$</span>-th residual is exactly decoupled from the <span>$i$</span>-th model if <span>$w^{(i)} \equiv 0$</span> and is sensitive to the <span>$j$</span>-th model, for all <span>$j \not = i$</span>. These requirements can be easily translated into algebraic conditions using the internal form of the <span>$i$</span>-th residual generator. We denote <span>$\widetilde R^{(i,j)}(\lambda)$</span> alternatively as</p><p class="math-container">\[\widetilde R^{(i,j)}(\lambda) := [\, R_u^{(i,j)}(\lambda) \;\; R_d^{(i,j)}(\lambda)\,] ,\]</p><p>if both control and disturbance inputs are involved in the model detection, or as</p><p class="math-container">\[\widetilde R^{(i,j)}(\lambda) := R_u^{(i,j)}(\lambda) ,\]</p><p>if only the control inputs have to be employed for model detection. Then the following conditions have to be always fulfilled for <span>$i = 1, \ldots, N$</span>:</p><p class="math-container">\[\begin{array}{ll}
  (i) &amp; [\, R_u^{(i,i)}(\lambda) \;\; R_d^{(i,i)}(\lambda)\,] = 0 , \\
  (ii) &amp; \widetilde R^{(i,j)}(\lambda) \not = 0, \;\; \forall j \not = i , \;\; j = 1,\ldots, N . 
\end{array}\]</p><p>Here, <span>$(i)$</span> is the <em>model decoupling condition</em> for the <span>$i$</span>-th model in the <span>$i$</span>-th residual component, while <span>$(ii)$</span> is the <em>model sensitivity condition</em> of the <span>$i$</span>-th residual component to all models, excepting the <span>$i$</span>-th model. In the case when condition <span>$(i)$</span> cannot be fulfilled (e.g., due to lack of sufficient measurements), some (or even all) components of <span>$d^{(j)}(t)$</span> can be redefined as noise inputs and included in <span>$w^{(j)}(t)$</span>.</p><p>In what follows, we formulate the exact and approximate model detection problems.</p><h3 id="Exact-model-detection-problem-(EMDP)"><a class="docs-heading-anchor" href="#Exact-model-detection-problem-(EMDP)">Exact model detection problem (EMDP)</a><a id="Exact-model-detection-problem-(EMDP)-1"></a><a class="docs-heading-anchor-permalink" href="#Exact-model-detection-problem-(EMDP)" title="Permalink"></a></h3><p><strong>EMDP:</strong> Determine <span>$N$</span> stable residual generator filters <span>$Q^{(i)}(\lambda)$</span> for <span>$i = 1, \ldots, N$</span> such that</p><p class="math-container">\[\begin{array}{ll}
  (i) &amp; [\, R_u^{(i,i)}(\lambda) \;\; R_d^{(i,i)}(\lambda)\,] = 0 , \\
  (ii) &amp; \widetilde R^{(i,j)}(\lambda) \not = 0, \;\; \forall j \not = i , \;\; j = 1,\ldots, N .
\end{array}\]</p><p>The conditions <span>$(i)$</span> and <span>$(ii)$</span> express the <em>model detectability</em> condition [1].</p><p>The EMDP can be formulated with the stronger requirement that <span>$\widetilde R^{(i,j)}(\lambda)$</span> do not vanish for a set of  relevant complex frequencies <span>$\Omega$</span> characterizing the classes of persistent inputs:</p><p><strong>EMDP with strong model detectability:</strong>  For a given set of complex frequencies <span>$\Omega$</span>,  determine <span>$N$</span> stable residual generator filters <span>$Q^{(i)}(\lambda)$</span> for <span>$i = 1, \ldots, N$</span> such that</p><p class="math-container">\[\begin{array}{ll}
  (i) &amp; [\, R_u^{(i,i)}(\lambda) \;\; R_d^{(i,i)}(\lambda)\,] = 0 , \\
  (ii)&#39; &amp; \widetilde R^{(i,j)}(\lambda_z) \not = 0, \forall \lambda_z \in \Omega, \;\; \forall j \not = i , \;\; j = 1,\ldots, N .
\end{array}\]</p><p>The conditions <span>$(i)$</span> and <span>$(ii)&#39;$</span> express the <em>strong model detectability</em> condition [1].</p><p>For the synthesis of model detection filters which solve the EMDP the function <a href="MDsynthesis.html#FaultDetectionTools.emdsyn"><code>emdsyn</code></a> is available. </p><h3 id="Approximate-model-detection-problem-(AMDP)"><a class="docs-heading-anchor" href="#Approximate-model-detection-problem-(AMDP)">Approximate model detection problem (AMDP)</a><a id="Approximate-model-detection-problem-(AMDP)-1"></a><a class="docs-heading-anchor-permalink" href="#Approximate-model-detection-problem-(AMDP)" title="Permalink"></a></h3><p><strong>AMDP:</strong> Determine <span>$N$</span> stable residual generator filters <span>$Q^{(i)}(\lambda)$</span> for <span>$i = 1, \ldots, N$</span> such that</p><p class="math-container">\[\begin{array}{ll}
  (i) &amp; [\, R_u^{(i,i)}(\lambda) \;\; R_d^{(i,i)}(\lambda)\,] = 0 , \\
  (ii) &amp; \widetilde R^{(i,j)}(\lambda) \not = 0, \;\; \forall j \not = i, \;\; j = 1,\ldots, N \\
  (iii) &amp; R_{w}^{(i,i)}(\lambda) \approx 0 . 
\end{array}\]</p><p>Here, <span>$(iii)$</span> is the <em>attenuation condition</em> of the effects of noise inputs.  A similar formulation can be done for the AMDP with strong model detectability.  </p><p>For the synthesis of model detection filters which solve the AMDP the function <a href="MDsynthesis.html#FaultDetectionTools.amdsyn"><code>amdsyn</code></a> is available. </p><h2 id="Analysis-and-performance-evaluation"><a class="docs-heading-anchor" href="#Analysis-and-performance-evaluation">Analysis and performance evaluation</a><a id="Analysis-and-performance-evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis-and-performance-evaluation" title="Permalink"></a></h2><h3 id="Distances-between-models"><a class="docs-heading-anchor" href="#Distances-between-models">Distances between models</a><a id="Distances-between-models-1"></a><a class="docs-heading-anchor-permalink" href="#Distances-between-models" title="Permalink"></a></h3><p>For the setup of model detection applications, an important first step is the selection of a representative set of component models to serve for the design of model detection filters. A practical requirement to set up multiple models is to choose a set of component models, such that, each component model is sufficiently far away of the rest of models. A suitable tool to measure the distance between two models is the <span>$\nu$</span>-gap metric introduced in [2]. For two transfer function matrices <span>$G_1(\lambda)$</span> and <span>$G_2(\lambda)$</span> of the same dimensions, we denote <span>$\delta_\nu(G_1(\lambda),G_2(\lambda))$</span> the  <span>$\nu$</span>-gap metric based distance [2], which generally satisfies <span>$0 \leq \delta_\nu(G_1(\lambda),G_2(\lambda))\leq 1$</span>. If <span>$\delta_\nu\big(G_1(\lambda),G_2(\lambda)\big)$</span> is small, then we can say that <span>$G_1(\lambda)$</span> and <span>$G_2(\lambda)$</span>  are close and it is likely that a model detection filter suited for <span>$G_1(\lambda)$</span> will also work with <span>$G_2(\lambda)$</span>, and therefore, one of the two models can be probably removed from the set of component models. On the other side, if <span>$\delta_\nu\big(G_1(\lambda),G_2(\lambda)\big)$</span>  is nearly equal to 1, then <span>$G_1(\lambda)$</span> and <span>$G_2(\lambda)$</span> are sufficiently distinct, such that an easy discrimination between the two models is possible. If the two models have the same number of outputs but different numbers of inputs, then <span>$G_1(\lambda)$</span> and <span>$G_2(\lambda)$</span> can be suitably padded with zero columns to arrive to a pair with equal number of columns.  </p><p>For a set of <span>$N$</span> component models, it is useful to determine the pairwise <span>$\nu$</span>-gap distances between the control input channels of the component models by defining the symmetric matrix <span>$\Delta$</span>, whose <span>$(i,j)$</span>-th entry is the <span>$\nu$</span>-gap distance between the transfer function matrices of the <span>$i$</span>-th and <span>$j$</span>-th model</p><p class="math-container">\[\Delta_{ij} := \delta_\nu\big(G_u^{(i)}(\lambda),G_u^{(j)}(\lambda)\big) . \]</p><p>It follows that <span>$\Delta$</span> has all its diagonal elements zero. For model detection applications all  off-diagonal elements of <span>$\Delta$</span> must be nonzero, otherwise there are models which can not be potentially discriminated. The above definition of the distances between the <span>$i$</span>-th and <span>$j$</span>-th models focuses only on the control input channels. In most of practical applications of the model detection, this is perfectly justified by the fact that, a certain control activity is always necessary, to ensure reliable discrimination among models, independently of the presence or absence of disturbances. However, if the disturbance inputs are relevant to perform model detection (e.g., there are no control inputs), then the definition of <span>$\Delta$</span> can be modified to include the disturbance inputs as well</p><p class="math-container">\[\Delta_{ij} := \delta_\nu\big(\big[\,G_u^{(i)}(\lambda)\;G_d^{(i)}(\lambda)\,\big],
\big[\,G_u^{(j)}(\lambda)\;G_d^{(j)}(\lambda)\,\big]\big) .\]</p><p>Recall that padding with zeros columns may be necessary if <span>$G_d^{(i)}(\lambda)$</span> and <span>$G_d^{(j)}(\lambda)$</span> have different number of columns. </p><p>If <span>$\lambda_k$</span>, <span>$k = 1, \ldots, n_f$</span>, is a set of <span>$n_f$</span> frequency values, then we can define the maximum of the point-wise distances</p><p class="math-container">\[\Delta_{ij} := \max_k\delta_\nu\big(G_u^{(i)}(\lambda_k),G_u^{(j)}(\lambda_k)\big) ,\]</p><p>or</p><p class="math-container">\[\Delta_{ij} := \max_k\delta_\nu\big(\big[\,G_u^{(i)}(\lambda_k)\;G_d^{(i)}(\lambda_k)\,\big],
\big[\,G_u^{(j)}(\lambda_k)\;G_d^{(j)}(\lambda_k)\,\big]\big) .\]</p><p>Besides the <span>$\nu$</span>-gap distance between two transfer function matrices, it is possible to use distances defined in terms of the <span>$\mathcal{H}_\infty$</span> norm or the <span>$\mathcal{H}_2$</span> norm of the difference between them:</p><p class="math-container">\[ \Delta_{ij} := \big\|G_u^{(i)}(\lambda)-G_u^{(j)}(\lambda)\big\|_\infty \]</p><p>or</p><p class="math-container">\[\Delta_{ij} := \big\|G_u^{(i)}(\lambda)-G_u^{(j)}(\lambda)\big\|_2. \]</p><p>If <span>$\lambda_k$</span>, <span>$k = 1, \ldots, n_f$</span>, is a set of <span>$n_f$</span> frequency values, then, instead of the above norm-based distances, we can use the maximum of the point-wise distances</p><p class="math-container">\[\Delta_{ij} := \max_k\big\|G_u^{(i)}(\lambda_k)-G_u^{(j)}(\lambda_k)\big\|_2. \]</p><p>For the evaluation of the above distances between component models the function <a href="MDanalysis.html#FaultDetectionTools.mddist"><code>mddist</code></a> is available. A second function <a href="MDanalysis.html#FaultDetectionTools.mddist2c"><code>mddist2c</code></a> can be employed to compute the pairwise distances between two sets of component models. In particular, this function is usefull to assess the nearness of a current model to the set of component models employed for model detection. </p><h3 id="Distance-mapping-performance"><a class="docs-heading-anchor" href="#Distance-mapping-performance">Distance mapping performance</a><a id="Distance-mapping-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-mapping-performance" title="Permalink"></a></h3><p>One of the goals of the model detection is to achieve a special mapping of the distances between <span>$N$</span> component models using <span>$N$</span> model detection filters such that the norms of the transfer function matrices <span>$R_u^{(i,j)}(\lambda)$</span>  or of <span>$\big[\, R_u^{(i,j)}(\lambda)\; R_d^{(i,j)}(\lambda)\,\big]$</span> in the internal forms of the filters qualitatively reproduce the <span>$\nu$</span>-gap distances expressed by the <span>$\Delta$</span> matrix above. The preservation of this distance  mapping property is highly desirable, and the choice of model detection filters must be able to ensure this feature (at least partially for the nearest models).  For example, the choice of the <span>$i$</span>-th filter <span>$Q^{(i)}(\lambda)$</span> as a left annihilator  of <span>$\left[\begin{smallmatrix} G_u^{(i)}(\lambda) &amp; G_d^{(i)}(\lambda) \\ I &amp; 0 \end{smallmatrix}\right]$</span> ensures (see Remark 6.1 of [1]) that the norm of <span>$\big[\, R_u^{(i,j)}(\lambda)\; R_d^{(i,j)}(\lambda)\,\big]$</span> can be interpreted as a weighted distance between the <span>$i$</span>-th and <span>$j$</span>-th component models. It follows that the distance mapping performance of a set of model detection filters <span>$Q^{(i)}(\lambda)$</span>, <span>$i = 1, \ldots, N$</span> can be assessed by computing the mapped distance matrix <span>$\Gamma$</span>, whose <span>$(i,j)$</span>-th entry is</p><p class="math-container">\[\Gamma_{ij} = \big\| R_u^{(i,j)}(\lambda) \big\|_\infty \]</p><p>or, if the disturbance inputs are relevant,</p><p class="math-container">\[\Gamma_{ij} = \big\| \big[\, R_u^{(i,j)}(\lambda)\; R_d^{(i,j)}(\lambda)\,\big]\big\|_\infty .\]</p><p>Using the above choice of the filter <span>$Q^{(i)}(\lambda)$</span>, we have that all diagonal elements of <span>$\Gamma$</span> are zero. Additionally, to guarantee model detectability, any valid design of the model detection filters must guarantee that all off-diagonal elements of <span>$\Gamma$</span> are nonzero. These two properties of <span>$\Gamma$</span> allows to unequivocally identify the exact matching of the current model with one (and only one) of the <span>$N$</span> component models.</p><p>Two other properties of <span>$\Gamma$</span> are desirable, when solving model detection applications. The first property is the symmetry of <span>$\Gamma$</span>. In contrast to <span>$\Delta$</span>,   <span>$\Gamma$</span> is generally not symmetric, excepting for some particular classes of component models and for special choices of model detection filters. For example, this property can be ensured if all component models are stable and have no disturbance inputs, by choosing <span>$Q^{(i)}(\lambda) = \big[\, I \; -G_u^{(i)}(\lambda)\,\big]$</span>, in which case <span>$R_u^{(i,j)}(\lambda) = -R_u^{(j,i)}(\lambda)$</span>. Ensuring the symmetry of <span>$\Gamma$</span>, although very desirable,  is in general difficult to be achieved. In practice, it is often sufficient to ensure via suitable scaling that the gains of first row and first column are equal.</p><p>The second desirable property of the mapping <span>$\Delta_{ij} \rightarrow \Gamma_{ij}$</span> is the <em>monotonic mapping property</em> of distances, which is the requirement that for all <span>$i$</span> and <span>$k$</span> (<span>$i, k = 1, \ldots, N$</span>), if <span>$\Delta_{ij} &lt; \Delta_{ik}$</span>, then <span>$\Gamma_{ij} &lt; \Gamma_{ik}$</span>. Ensuring this property, makes easier to address model identification problems for which no exact matching between the current model and any one of the component models can be assumed.</p><p>If <span>$\lambda_k$</span>, <span>$k = 1, \ldots, n_f$</span>, is a given set of <span>$n_f$</span> frequency values, then, instead of the peak distances, we can use the maximum of the point-wise distances over the finite set of frequency values, to assess the strong model detectability.</p><p>For the evaluation of the distance mapping performance the function <a href="MDperformance.html#FaultDetectionTools.mdperf"><code>mdperf</code></a> is available. </p><h3 id="Distance-matching-performance"><a class="docs-heading-anchor" href="#Distance-matching-performance">Distance matching performance</a><a id="Distance-matching-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-matching-performance" title="Permalink"></a></h3><p>To evaluate the distance matching property of the model detection filters in the case when no exact matching between the current model and any one of the component models can be assumed, we can define the corresponding current internal forms as</p><p class="math-container">\[\big[ \widetilde R_u^{(i)}(\lambda) \mid \widetilde R_d^{(i)}(\lambda) \mid \widetilde R_w^{(i)}(\lambda)\big] :=
Q^{(i)}(\lambda)\left[ \begin{array}{c|c|c} \widetilde G_u(\lambda) &amp; \widetilde G_d(\lambda) &amp; \widetilde G_w(\lambda) \\
I_{m_u} &amp; 0 &amp; 0 \end{array} \right]\]</p><p>and evaluate the mapped distances <span>$\gamma_i$</span>, for <span>$i = 1, \ldots, N$</span>, defined as</p><p class="math-container">\[\gamma_i := \big\| \widetilde R_u^{(i)}(\lambda) \big\|_\infty \]</p><p>or, if the disturbance inputs are relevant,</p><p class="math-container">\[\gamma_i := \big\| \big[\,  \widetilde R_u^{(i)}(\lambda)\; \widetilde R_d^{(i)}(\lambda)\,\big]\big\|_\infty .\]</p><p>The index <span>$\ell$</span> of the smallest value <span>$\gamma_\ell$</span> provides (for a well designed set of model detection filters) the index of the best matching component model of the current model.</p><p>If <span>$\lambda_k$</span>, <span>$k = 1, \ldots, n_f$</span>, is a given set of <span>$n_f$</span> frequency values, then, instead of the above peak distances, we can use the maximum of the point-wise distances over the finite set of frequency values.</p><p>For the evaluation of the distance matching performance the function <a href="MDperformance.html#FaultDetectionTools.mdmatch"><code>mdmatch</code></a> is available. </p><h3 id="Model-detection-noise-gaps"><a class="docs-heading-anchor" href="#Model-detection-noise-gaps">Model detection noise gaps</a><a id="Model-detection-noise-gaps-1"></a><a class="docs-heading-anchor-permalink" href="#Model-detection-noise-gaps" title="Permalink"></a></h3><p>The noise attenuation performance of model detection filters can be characterized via the noise gaps achieved by individual filters. The noise gap for the <span>$i$</span>-th filter can be defined in terms of the resulting internal forms as the ratio <span>$\eta_i := \beta_i/\gamma_i$</span>, where</p><p class="math-container">\[\beta_i := \min_{j\neq i} \big\|R_u^{(i,j)}(\lambda)\big\|_\infty \]</p><p>and</p><p class="math-container">\[\gamma_i := \big\|R_w^{(i,i)}(\lambda)\big\|_\infty .\]</p><p>The values of <span>$\beta_i &gt; 0$</span>, for <span>$i = 1, \ldots, N$</span> characterize the model detectability property of the collection of the <span>$N$</span> component models, while <span>$\gamma_i$</span> characterizes the worst-case influence of noise inputs on the <span>$i$</span>-th residual component. If <span>$\gamma_i = 0$</span> (no noise), then <span>$\eta_i = \infty$</span>.</p><p>If the disturbance inputs are relevant for the model detection, then we can use the following alternative definition of <span>$\beta_i$</span></p><p class="math-container">\[\beta_i := \min_{j\neq i} \big\|\big[\,R_u^{(i,j)}(\lambda)\; R_d^{(i,j)}(\lambda)\,\big]\big\|_\infty .\]</p><p>In this case, <span>$\beta_i &gt; 0$</span>, for <span>$i = 1, \ldots, N$</span> characterize the (extended) model detectability property of the collection of the <span>$N$</span> component models.</p><p>If <span>$\lambda_k$</span>, <span>$k = 1, \ldots, n_f$</span>, is a given set of <span>$n_f$</span> frequency values, then we can alternatively use the maximum of the point-wise distances over the finite set of frequency values</p><p class="math-container">\[\beta_i := \min_{j\neq i} \max_k\big\|R_u^{(i,j)}(\lambda_k)\big\|_\infty \]</p><p>or</p><p class="math-container">\[\beta_i := \min_{j\neq i} \max_k\big\|\big[\,R_u^{(i,j)}(\lambda_k)\; R_d^{(i,j)}(\lambda_k)\,\big]\big\|_\infty .\]</p><p>For the evaluation of the detection noise gaps the function <a href="MDperformance.html#FaultDetectionTools.mdgap"><code>mdgap</code></a> is available. </p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.</p><p>[2]  G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="FDDbasics.html">« Fault detection and diagnosis basics</a><a class="docs-footer-nextpage" href="SynthesisParadigms.html">Synthesis paradigms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 31 October 2025 15:11">Friday 31 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
