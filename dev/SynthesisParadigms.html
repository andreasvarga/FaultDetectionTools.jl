<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis paradigms · FaultDetectionTools.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">FaultDetectionTools.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="FDDbasics.html">Fault detection and diagnosis basics</a></li><li><a class="tocitem" href="MDbasics.html">Model detection basics</a></li><li class="is-active"><a class="tocitem" href="SynthesisParadigms.html">Synthesis paradigms</a><ul class="internal"><li><a class="tocitem" href="#Nullspace-based-synthesis"><span>Nullspace-based synthesis</span></a></li><li><a class="tocitem" href="#Using-filter-updating-techniques"><span>Using filter updating techniques</span></a></li><li><a class="tocitem" href="#Least-order-synthesis-based-on-admissibility-conditions"><span>Least order synthesis based on admissibility conditions</span></a></li><li><a class="tocitem" href="#Stabilization-via-left-coprime-factorization"><span>Stabilization via left coprime factorization</span></a></li></ul></li></ul></li><li><span class="tocitem">Fault Detection</span><ul><li><a class="tocitem" href="FDIObjects.html">Building fault detection and isolation related objects</a></li><li><a class="tocitem" href="FDIanalysis.html">Analysis of FDI synthesis models</a></li><li><a class="tocitem" href="FDIsynthesis.html">Solving fault detection and isolation problems</a></li><li><a class="tocitem" href="FDIperformance.html">Performance evaluation of FDI filters</a></li></ul></li><li><span class="tocitem">Model Detection</span><ul><li><a class="tocitem" href="MDObjects.html">Building model detection related objects</a></li><li><a class="tocitem" href="MDanalysis.html">Analysis of model detection synthesis models</a></li><li><a class="tocitem" href="MDsynthesis.html">Solving model detection problems</a></li><li><a class="tocitem" href="MDperformance.html">Performance evaluation of model detection filters</a></li></ul></li><li><span class="tocitem">Residual Evaluation</span><ul><li><a class="tocitem" href="FDDsystems.html">Building fault detection and diagnosis systems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="FDIutils.html">FDI related utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href="SynthesisParadigms.html">Synthesis paradigms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="SynthesisParadigms.html">Synthesis paradigms</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/FaultDetectionTools.jl/blob/master/docs/src/SynthesisParadigms.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Synthesis-paradigms"><a class="docs-heading-anchor" href="#Synthesis-paradigms">Synthesis paradigms</a><a id="Synthesis-paradigms-1"></a><a class="docs-heading-anchor-permalink" href="#Synthesis-paradigms" title="Permalink"></a></h1><p>The implemented computational procedures for the synthesis of fault detection filters share several computational paradigms, which are instrumental in developing generally applicable, numerically reliable and computationally efficient synthesis methods. Similar paradigms are also present in the synthesis methods of model detection filters.  In what follows we shortly review these paradigms and discuss their roles in the synthesis procedures.</p><h2 id="Nullspace-based-synthesis"><a class="docs-heading-anchor" href="#Nullspace-based-synthesis">Nullspace-based synthesis</a><a id="Nullspace-based-synthesis-1"></a><a class="docs-heading-anchor-permalink" href="#Nullspace-based-synthesis" title="Permalink"></a></h2><p>An important synthesis paradigm is the use of the nullspace method as a first synthesis step to ensure the fulfillment of the decoupling conditions  <span>$R_u(\lambda) = 0$</span> and <span>$R_d(\lambda) = 0$</span>. This can be done by choosing <span>$Q(\lambda)$</span> of the form</p><p class="math-container">\[ Q(\lambda) = \overline Q_1(\lambda) Q_1(\lambda) , \]</p><p>where the factor <span>$Q_1(\lambda)$</span> is a left nullspace basis of the rational matrix</p><p class="math-container">\[G(\lambda) := \left[ \begin{array}{cc} G_u(\lambda) &amp; G_d(\lambda) \\ I_{m_u} &amp; 0 \end{array}\right] \, .\]</p><p>It follows</p><p class="math-container">\[[\,R_u(\lambda) \; R_d(\lambda)\,] = Q(\lambda)G(\lambda)= 0 \, .\]</p><p>The residual generator filter can be rewritten in the alternative form</p><p class="math-container">\[{\mathbf{r}}(\lambda) = \overline Q_1(\lambda)Q_1(\lambda)\left[ \begin{array}{c}
{\mathbf{y}}(\lambda)\\{\mathbf{u}}(\lambda)\end{array}\right] = \overline Q_1(\lambda) \overline{\mathbf{y}}(\lambda) \;, \]</p><p>where</p><p class="math-container">\[\overline{\mathbf{y}}(\lambda) := Q_1(\lambda)\left[\begin{array}{c}
{\mathbf{y}}(\lambda)\\{\mathbf{u}}(\lambda)\end{array}\right] = \overline G_f(\lambda){\mathbf{f}}(\lambda) + \overline G_w(\lambda){\mathbf{w}}(\lambda)  \,,\]</p><p>with</p><p class="math-container">\[[\, \overline G_f(\lambda) \; \overline G_w(\lambda) \,] := Q_1(\lambda)
\left[ \begin{array}{cc} G_f(\lambda) &amp; G_w(\lambda) \\ 0 &amp; 0 \end{array}\right]\, .\]</p><p>With this first preprocessing step, the original problems formulated for a system with control and disturbance inputs can be reformulated for the above reduced system (without control and disturbance inputs),  for which we have to determine the TFM <span>$\overline Q_1(\lambda)$</span> of the simpler fault detection filter. For the details of the implemented computational approach see Section 7.4 of [1]. </p><p>For the computation of nullspace bases, functions available in the <a href="https://github.com/andreasvarga/DescriptorSystems.jl">DescriptorSystems</a> package are employed. </p><h2 id="Using-filter-updating-techniques"><a class="docs-heading-anchor" href="#Using-filter-updating-techniques">Using filter updating techniques</a><a id="Using-filter-updating-techniques-1"></a><a class="docs-heading-anchor-permalink" href="#Using-filter-updating-techniques" title="Permalink"></a></h2><p>In all implemented synthesis procedures, the TFM of the resulting filter <span>$Q(\lambda)$</span> can be expressed in a factored form as</p><p class="math-container">\[Q(\lambda) = Q_K(\lambda) \cdots Q_2(\lambda)Q_1(\lambda) \, , \]</p><p>where <span>$Q_1(\lambda)$</span> is a left nullspace basis of the above defined <span>$G(\lambda)$</span>, satisfying <span>$Q_1(\lambda)G(\lambda) = 0$</span>, and  <span>$Q_1(\lambda)$</span>, <span>$Q_2(\lambda)Q_1(\lambda)$</span>, <span>$\ldots$</span>, can be interpreted as partial syntheses addressing specific requirements. Since each partial synthesis may represent a valid fault detection filter, this approach can be flexibly used  for employing or combining different synthesis techniques.</p><p>The determination of <span>$Q(\lambda)$</span> in the above factored form can be formulated as a <span>$K$</span>-step synthesis procedure based on successive updating of an initial filter <span>$Q(\lambda) = Q_1(\lambda)$</span> and the nonzero terms of its corresponding  internal form</p><p class="math-container">\[R(\lambda) := [\, R_f(\lambda) \; R_w(\lambda)\,] = Q_1(\lambda)\left[ \begin{array}{cc} G_f(\lambda) &amp; G_w(\lambda) \\  0 &amp; 0 \end{array}\right]\]</p><p>as follows: for <span>$k = 2, \ldots, K$</span>, determine <span>$Q_k(\lambda)$</span> using the current <span>$Q(\lambda)$</span> and <span>$R(\lambda)$</span> and  then perform the updating as <span>$Q(\lambda) \leftarrow Q_k(\lambda)Q(\lambda)$</span> and  <span>$R(\lambda) \leftarrow Q_k(\lambda)R(\lambda)$</span>. These updating operations are efficiently performed using state-space description based formulas. The main benefit of using explicit state-space based updating formulas is the possibility to ensure at each step the cancellation of a maximum number of poles and zeros between the factors. This allows to keep the final order of the filter <span>$Q(\lambda)$</span> as low as possible. See Section 7.3 of [1] for a discussion of additional aspects. </p><h2 id="Least-order-synthesis-based-on-admissibility-conditions"><a class="docs-heading-anchor" href="#Least-order-synthesis-based-on-admissibility-conditions">Least order synthesis based on admissibility conditions</a><a id="Least-order-synthesis-based-on-admissibility-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Least-order-synthesis-based-on-admissibility-conditions" title="Permalink"></a></h2><p>The least order synthesis of fault detection filters means to determine filters <span>$Q(\lambda)$</span> with the least possible orders, to help in reducing the computational burden associated with their real-time implementations. The main tool to achieve least order synthesis is the solution of suitable <em>minimal cover problems</em> (see Section 7.5 of [1]). If <span>$X_1(\lambda)$</span> and <span>$X_2(\lambda)$</span> are rational matrices of the same column dimension,  then the <em>left minimal cover problem</em> is to find <span>$X(\lambda)$</span> and <span>$Y(\lambda)$</span> such that</p><p class="math-container">\[X(\lambda) = X_1(\lambda) + Y(\lambda) X_2(\lambda) , \]</p><p>and the order of <span>$[\,X(\lambda) \; Y(\lambda) \,]$</span> is minimal.</p><p>A typical second step in many synthesis procedures is to choose <span>$Q_2(\lambda)$</span> such that the product <span>$Q_2(\lambda)Q(\lambda)$</span> has least dynamical order and, simultaneously, a certain <em>admissibility</em> condition is fulfilled (usually involving the nonzero TFMs <span>$R_f(\lambda)$</span> and <span>$R_w(\lambda)$</span>). For example, for the solution of the AFDP, the rows of <span>$Q(\lambda) := Q_1(\lambda)$</span> form a left nullspace basis and the employed admissibility conditions  are</p><p class="math-container">\[Q_2(\lambda)R_{f_j}(\lambda) \not = 0, \;\;j = 1, \ldots, m_f, \]</p><p>which  guarantee the detectability of all fault components, and additionally, the full row rank requirement on <span>$Q_2(\lambda)R_w(\lambda)$</span>. The latter condition is only imposed for convenience, to simplify the subsequent computational steps. </p><p>The determination of candidate solutions <span>$Q_2(\lambda)$</span> such that <span>$Q_2(\lambda)Q(\lambda)$</span> has least order  can be done by solving left minimal cover problems, where <span>$X_1(\lambda)$</span> and <span>$X_2(\lambda)$</span> represent disjoint subsets of basis vectors, such that: <span>$Q(\lambda) = \left[\begin{smallmatrix} X_1(\lambda) \\ X_2(\lambda) \end{smallmatrix}\right]$</span>, <span>$Q_2(\lambda) = [\, I \;\; Y(\lambda)\,]$</span>,  and <span>$X(\lambda) = Q_2(\lambda)Q(\lambda)$</span> and <span>$Y(\lambda)$</span> represent the solution of the left cover problem. A systematic search over increasing orders of candidate solutions can be performed and the search stops when the admissibility conditions are fulfilled.</p><p>State-space representation based computational methods for the solution of minimum dynamic cover problems are described in Sections 7.5 and 10.4 of [1], together with explicit updating formulas of the state-space realizations of  <span>$Q(\lambda)$</span> and <span>$R(\lambda)$</span>.</p><p>For the solution of minimal cover problems, functions available in the <a href="https://github.com/andreasvarga/DescriptorSystems.jl">DescriptorSystems</a> package are employed. </p><h2 id="Stabilization-via-left-coprime-factorization"><a class="docs-heading-anchor" href="#Stabilization-via-left-coprime-factorization">Stabilization via left coprime factorization</a><a id="Stabilization-via-left-coprime-factorization-1"></a><a class="docs-heading-anchor-permalink" href="#Stabilization-via-left-coprime-factorization" title="Permalink"></a></h2><p>A desired dynamics of the resulting final filters <span>$Q(\lambda)$</span> and <span>$R(\lambda)$</span> can be enforced by choosing a suitable invertible factor <span>$M(\lambda)$</span>, such that  <span>$M(\lambda)[\, Q(\lambda) \; R(\lambda) \,]$</span> has desired poles. This can be achieved by computing a left coprime factorization</p><p class="math-container">\[[\, Q(\lambda) \; R(\lambda) \,] = M^{-1}(\lambda) [\, N_Q(\lambda) \; N_R(\lambda) \,] \]</p><p>with <span>$M(\lambda)$</span> and <span>$[\, N_Q(\lambda) \; N_R(\lambda) \,]$</span> coprime and having arbitrary stable poles, and then performing the updating operations <span>$Q(\lambda) \leftarrow N_Q(\lambda)$</span> and  <span>$R(\lambda) \leftarrow N_R(\lambda)$</span>. The stabilization via a left coprime factorization is usually performed as the last step of the synthesis procedures. </p><p>For a detailed discussion of the coprime factorization based stabilization approach see Sections 7.6 and 10.4 of [1], where coprime factorization methods, based on recursive pole dislocation techniques are described, which produce directly the numerator factors <span>$N_Q(\lambda)$</span> and <span>$N_R(\lambda)$</span> (thus implicitly perform  the updating operations as well).</p><p>For the solution of coprime factorizations, functions available in the <a href="https://github.com/andreasvarga/DescriptorSystems.jl">DescriptorSystems</a> package are employed. </p><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><p>[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="MDbasics.html">« Model detection basics</a><a class="docs-footer-nextpage" href="FDIObjects.html">Building fault detection and isolation related objects »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 31 October 2025 21:22">Friday 31 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
